<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Stack Machines for Free :: [ recursion.wtf ]</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Previously we saw how to expand seed values into recursive structures given a function that expands a single layer of structure, and how to collapse recursive structures into a single value given a function that consumes a single layer of structure. Here we&#39;ll see how to fuse those two steps, to generate a stack machine that simultaneously expands and collapses recursive structures, given just a function for expanding layers and a function for collapsing layers.
" />
<meta name="keywords" content="recursion schemes, rust, code, stack_machines" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://recursion.wtf/posts/rust_schemes_3/" />




<link rel="stylesheet" href="https://recursion.wtf/assets/style.css">

  <link rel="stylesheet" href="https://recursion.wtf/assets/blue.css">






<link rel="apple-touch-icon" href="https://recursion.wtf/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="https://recursion.wtf/img/favicon/blue.png">



<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="inanna_malick" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Stack Machines for Free">
<meta property="og:description" content="Previously we saw how to expand seed values into recursive structures given a function that expands a single layer of structure, and how to collapse recursive structures into a single value given a function that consumes a single layer of structure. Here we&#39;ll see how to fuse those two steps, to generate a stack machine that simultaneously expands and collapses recursive structures, given just a function for expanding layers and a function for collapsing layers.
" />
<meta property="og:url" content="https://recursion.wtf/posts/rust_schemes_3/" />
<meta property="og:site_name" content="[ recursion.wtf ]" />

  <meta property="og:image" content="https://recursion.wtf/img/rust_schemes/stack_machines_1/simple_expr_eval.gif">

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2000-09-01 00:00:00 &#43;0000 UTC" />












</head>
<body class="blue">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Inanna Malick
  </div>
</a>

    </div>
    
      <div class="menu-trigger">menu</div>
    
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="https://github.com/inanna-malick/">Github</a></li>
        
      
        
          <li><a href="https://twitter.com/inanna_malick">Twitter</a></li>
        
      
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="https://github.com/inanna-malick/">Github</a></li>
      
    
      
        <li><a href="https://twitter.com/inanna_malick">Twitter</a></li>
      
    
    
  </ul>
</nav>

  

  <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://recursion.wtf/img/rust_schemes/.png"/>

<meta name="twitter:title" content="Stack Machines for Free"/>
<meta name="twitter:description" content="Previously we saw how to expand seed values into recursive structures given a function that expands a single layer of structure, and how to collapse recursive structures into a single value given a function that consumes a single layer of structure. Here we&#39;ll see how to fuse those two steps, to generate a stack machine that simultaneously expands and collapses recursive structures, given just a function for expanding layers and a function for collapsing layers.

  "/>

  <meta property="og:title" content="Stack Machines for Free" />
<meta property="og:description" content="Previously we saw how to expand seed values into recursive structures given a function that expands a single layer of structure, and how to collapse recursive structures into a single value given a function that consumes a single layer of structure. Here we&#39;ll see how to fuse those two steps, to generate a stack machine that simultaneously expands and collapses recursive structures, given just a function for expanding layers and a function for collapsing layers.

  " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://recursion.wtf/posts/rust_schemes_3/" />
<meta property="og:image" content="https://recursion.wtf/img/rust_schemes/.png" />
<meta property="article:published_time" content="2000-09-01T00:00:00+00:00" />
<meta property="article:modified_time" content="2000-09-01T00:00:00+00:00" /><meta property="og:site_name" content="[ recursion.wtf ]" />



</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://recursion.wtf/posts/rust_schemes_3/">Stack Machines for Free</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2000-09-01 
      </span>
    
    
    <span class="post-author">:: Inanna Malick</span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="https://recursion.wtf/tags/recursion-schemes/">recursion schemes</a>&nbsp;
    
    #<a href="https://recursion.wtf/tags/rust/">rust</a>&nbsp;
    
    #<a href="https://recursion.wtf/tags/code/">code</a>&nbsp;
    
    #<a href="https://recursion.wtf/tags/generic/">generic</a>&nbsp;
    
    #<a href="https://recursion.wtf/tags/stack_machines/">stack_machines</a>&nbsp;
    
  </span>
  

  
  

  

  <div class="post-content"><div>
        <p>Previously we saw how to expand seed values into recursive structures given a function that expands a single layer of structure, and how to collapse recursive structures into a single value given a function that consumes a single layer of structure. Here we'll see how to fuse those two steps, to generate a stack machine that simultaneously expands and collapses recursive structures, given just a function for expanding layers and a function for collapsing layers.</p>

  <img src="/img/rust_schemes/stack_machines_1/simple_expr_eval.gif"  alt="execution graph for simultaneously expanding and collapsing a simple expression"  class="center"  style="border-radius: 8px;"  />


<h1 id="a-recap">A Recap<a href="#a-recap" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>In the last two posts, we introduced a stack safe and ergonomic method for expressing recursion in Rust, and then made a generic implementation of same. This generic recursion backend is implemented in my <a href="https://crates.io/crates/recursion">recursion</a> crate. Docs are <a href="https://docs.rs/recursion">here</a>. Source code, along with examples and benchmarks, <a href="https://github.com/inanna-malick/recursion">can be found here</a>.</p>
<h2 id="our-expression-language">Our Expression Language<a href="#our-expression-language" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Earlier in this series we defined a simple expression language for math, using an enum to represent <em>a single layer</em> of an expression tree:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">ExprLayer</span><span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span> {
    Add { a: <span style="color:#a6e22e">A</span>, b: <span style="color:#a6e22e">A</span> },
    Sub { a: <span style="color:#a6e22e">A</span>, b: <span style="color:#a6e22e">A</span> },
    Mul { a: <span style="color:#a6e22e">A</span>, b: <span style="color:#a6e22e">A</span> },
    LiteralInt { literal: <span style="color:#66d9ef">i64</span> },
}
</code></pre></div><p>So that we can easily write expressions out by hand (for test cases and examples), let's define a simple boxed pointer expression tree:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ExprBoxed</span>(Box<span style="color:#f92672">&lt;</span>ExprLayer<span style="color:#f92672">&lt;</span>ExprBoxed<span style="color:#f92672">&gt;&gt;</span>);

<span style="color:#75715e">// some simple utility functions for creating boxed expressions
</span><span style="color:#75715e"></span><span style="color:#66d9ef">impl</span> ExprBoxed {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">add</span>(a: <span style="color:#a6e22e">Self</span>, b: <span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Self</span> { ... }
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sub</span>(a: <span style="color:#a6e22e">Self</span>, b: <span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Self</span> { ... }
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">mul</span>(a: <span style="color:#a6e22e">Self</span>, b: <span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Self</span> { ... }
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">literal_int</span>(x: <span style="color:#66d9ef">i64</span>) -&gt; <span style="color:#a6e22e">Self</span> { ... }
}
</code></pre></div><p>In this post we'll be working with the expression <code>5 - 3 * 3 + 12</code>. Here's what that looks like as code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> ExprBoxed::<span style="color:#f92672">*</span>;
<span style="color:#66d9ef">let</span> expr <span style="color:#f92672">=</span> mul(
	sub(literal_int(<span style="color:#ae81ff">4</span>), literal_int(<span style="color:#ae81ff">3</span>)),
	add(literal_int(<span style="color:#ae81ff">2</span>), literal_int(<span style="color:#ae81ff">12</span>)),
);
</code></pre></div><h2 id="expand-and-collapse">Expand and Collapse<a href="#expand-and-collapse" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Previously, we defined two core traits representing the ability to expand a recursive structure out from some seed, and to collapse a recursive structure down into a single value:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#e6db74">/// Support for expanding a data structure from a seed value, one layer at a time
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Expand<span style="color:#f92672">&lt;</span>A, Wrapped<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">expand_layers</span><span style="color:#f92672">&lt;</span>F: Fn(A) -&gt; <span style="color:#a6e22e">Wrapped</span><span style="color:#f92672">&gt;</span>(a: <span style="color:#a6e22e">A</span>, expand_layer: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Self</span>;
}

<span style="color:#e6db74">/// Support for collapsing a data structure into a single value, one layer at a time
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Collapse<span style="color:#f92672">&lt;</span>A, Wrapped<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">collapse_layers</span><span style="color:#f92672">&lt;</span>F: FnMut(Wrapped) -&gt; <span style="color:#a6e22e">A</span><span style="color:#f92672">&gt;</span>(self, collapse_layer: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">A</span>;
}
</code></pre></div><p>We'll be using those traits in this post, to introduce a new recursion backend.</p>
<h1 id="stack-machines">Stack Machines<a href="#stack-machines" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Stack machines can be thought of as a <em>purpose-specific implementation of the call stack</em>  for a specific recursive function.</p>
<h2 id="data-at-rest">Data At Rest<a href="#data-at-rest" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Instead of using a vector of elements linked by vector indices, we construct a vector where linkages are defined only by the <em>position</em> of elements. This lets us replace the <code>usize</code> vector indices with zero-size markers that, instead of representing a specific index, just indicate that we should pop one element off the stack.  This results in an extremely compact representation of recursive structures.</p>
<p>Here's what the data structure looks like</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#e6db74">/// Recursive tree made up of layers of some type &#39;Layer&lt;_&gt;&#39;, eg `ExprLayer&lt;_&gt;`
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">RecursiveTree</span><span style="color:#f92672">&lt;</span>Wrapped<span style="color:#f92672">&gt;</span> {
    <span style="color:#e6db74">/// nonempty, in topological-sorted order
</span><span style="color:#e6db74"></span>    elems: Vec<span style="color:#f92672">&lt;</span>Wrapped<span style="color:#f92672">&gt;</span>, <span style="color:#75715e">// Layer&lt;Index&gt; (eg `ExprLayer&lt;()&gt;`)
</span><span style="color:#75715e"></span>}
</code></pre></div><p>Here's a visualization of what this might look like for the expression <code>5 - 3 * 3 + 12</code>.</p>

  <img src="/img/rust_schemes/stack_machines_1/simple_expr_structure.png"  alt="simple expr data at rest"  class="center"  style="border-radius: 8px;"  />


<h2 id="expand">Expand<a href="#expand" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Expanding out the data structure takes the form of a depth-first traversal. Layers are generated and pushed onto a vector of elements, which then forms the <code>RecursiveTree</code>. Feel free to skim the implementation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>A, Underlying, O: <span style="color:#a6e22e">MapLayer</span><span style="color:#f92672">&lt;</span>(), Unwrapped <span style="color:#f92672">=</span> A, To <span style="color:#f92672">=</span> U<span style="color:#f92672">&gt;&gt;</span> Expand<span style="color:#f92672">&lt;</span>A, O<span style="color:#f92672">&gt;</span>
    <span style="color:#66d9ef">for</span> RecursiveTree<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span>
{
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">expand_layers</span><span style="color:#f92672">&lt;</span>F: Fn(A) -&gt; <span style="color:#a6e22e">O</span><span style="color:#f92672">&gt;</span>(a: <span style="color:#a6e22e">A</span>, generate_layer: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Self</span> {
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> frontier <span style="color:#f92672">=</span> Vec::from([a]);
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> elems <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[];

        <span style="color:#75715e">// expand to build a vec of elems while preserving depth-first topo order
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(seed) <span style="color:#f92672">=</span> frontier.pop() {
            <span style="color:#66d9ef">let</span> layer <span style="color:#f92672">=</span> generate_layer(seed);

            <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> topush <span style="color:#f92672">=</span> Vec::new();
            <span style="color:#66d9ef">let</span> layer <span style="color:#f92672">=</span> layer.map_layer(<span style="color:#f92672">|</span>aa<span style="color:#f92672">|</span> {
                topush.push(aa);
                ()
            });
            frontier.extend(topush.into_iter().rev());

            elems.push(layer);
        }

        elems.reverse();

        Self {elems}
    }
}
</code></pre></div><p>Let's see what this looks like when expanding  <code>5 - 3 * 3 + 12</code> into a recursive tree. Since it's already made up of layers, we can just dereference the boxed value.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> expr_tree <span style="color:#f92672">=</span> RecursiveTree::expand(boxed_expr_tree, <span style="color:#f92672">|</span>ExprBoxed(boxed)<span style="color:#f92672">|</span> <span style="color:#f92672">*</span>boxed)
</code></pre></div>
  <img src="/img/rust_schemes/stack_machines_1/simple_expr_expand_only.gif"  alt="execution graph for expansion of a simple expression"  class="center"  style="border-radius: 8px;"  />


<h2 id="collapse">Collapse<a href="#collapse" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Here's how we collapse a recursive tree. As with the previous <code>expand_layers</code> implementation, it's fine to just skim this code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>A, O, U: <span style="color:#a6e22e">MapLayer</span><span style="color:#f92672">&lt;</span>A, To <span style="color:#f92672">=</span> O, Unwrapped <span style="color:#f92672">=</span> ()<span style="color:#f92672">&gt;&gt;</span> Collapse<span style="color:#f92672">&lt;</span>A, O<span style="color:#f92672">&gt;</span>
    <span style="color:#66d9ef">for</span> RecursiveTree<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span>
{
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">collapse_layers</span><span style="color:#f92672">&lt;</span>F: FnMut(O) -&gt; <span style="color:#a6e22e">A</span><span style="color:#f92672">&gt;</span>(self, <span style="color:#66d9ef">mut</span> collapse_layer: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">A</span> {
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> result_stack <span style="color:#f92672">=</span> Vec::new();

        <span style="color:#66d9ef">for</span> layer <span style="color:#66d9ef">in</span> self.elems.into_iter() {
            <span style="color:#66d9ef">let</span> layer <span style="color:#f92672">=</span> layer.map_layer(<span style="color:#f92672">|</span>_<span style="color:#f92672">|</span> result_stack.pop().unwrap());

            result_stack.push(collapse_layer(layer));
        }

        result_stack.pop().unwrap()
    }
}
</code></pre></div><p>Let's see what this looks like when collapsing  <code>5 - 3 * 3 + 12</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> recursive_tree.collapse_layers(<span style="color:#f92672">|</span>expr<span style="color:#f92672">|</span> {
    <span style="color:#66d9ef">use</span> ExprLayer::<span style="color:#f92672">*</span>;
	<span style="color:#66d9ef">match</span> expr {
        Add { a, b } <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">+</span> b,
        Sub { a, b } <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">-</span> b,
        Mul { a, b } <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">*</span> b,
        LiteralInt { literal } <span style="color:#f92672">=&gt;</span> literal,
	}
})
</code></pre></div>
  <img src="/img/rust_schemes/stack_machines_1/simple_expr_collapse_only.gif"  alt="execution graph for collapsing of a simple expression"  class="center"  style="border-radius: 8px;"  />


<h1 id="fusing-the-stages">Fusing the stages<a href="#fusing-the-stages" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<h2 id="why--bother">Why  Bother?<a href="#why--bother" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>As a reminder, the data at rest for the expression evaluation shown above looks like this:</p>

  <img src="/img/rust_schemes/stack_machines_1/simple_expr_structure.png"  alt="simple expr data at rest"  class="center"  style="border-radius: 8px;"  />


<p>Here's what the full evaluation looks like, if we run expand immediately followed by collapse</p>

  <img src="/img/rust_schemes/stack_machines_1/simple_expr_eval_sorted.gif"  alt="execution graph for expanding and then collapsing a simple expression"  class="center"  style="border-radius: 8px;"  />


<h2 id="expand-and-collapse-1">Expand And Collapse<a href="#expand-and-collapse-1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>But what if we could avoid holding all of this in memory? It should be possible to evaluate the expression like this, one branch at a time:</p>

  <img src="/img/rust_schemes/stack_machines_1/simple_expr_eval.gif"  alt="execution graph for simultaneously expanding and collapsing a simple expression"  class="center"  style="border-radius: 8px;"  />


<p>The code here is a bit complex, so don't worry about understanding all of the internals. At the conceptual level, it's just a stack machine built by fusing the expand and collapse stages defined earlier in this post.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">expand_and_collapse</span><span style="color:#f92672">&lt;</span>Seed, Out, Expandable, Collapsable<span style="color:#f92672">&gt;</span>(
    seed: <span style="color:#a6e22e">Seed</span>,
    <span style="color:#66d9ef">mut</span> expand_layer: <span style="color:#a6e22e">impl</span> FnMut(Seed) -&gt; <span style="color:#a6e22e">Expandable</span>,
    <span style="color:#66d9ef">mut</span> collapse_layer: <span style="color:#a6e22e">impl</span> FnMut(Collapsable) -&gt; <span style="color:#a6e22e">Out</span>,
) -&gt; <span style="color:#a6e22e">Out</span>
<span style="color:#66d9ef">where</span>
    Expandable: <span style="color:#a6e22e">MapLayer</span><span style="color:#f92672">&lt;</span>(), Unwrapped <span style="color:#f92672">=</span> Seed<span style="color:#f92672">&gt;</span>,
    <span style="color:#f92672">&lt;</span>Expandable <span style="color:#66d9ef">as</span> MapLayer<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;&gt;</span>::To: <span style="color:#a6e22e">MapLayer</span><span style="color:#f92672">&lt;</span>Out, Unwrapped <span style="color:#f92672">=</span> (), To <span style="color:#f92672">=</span> Collapsable<span style="color:#f92672">&gt;</span>,
{
    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">State</span><span style="color:#f92672">&lt;</span>Seed, CollapsableInternal<span style="color:#f92672">&gt;</span> {
        Expand(Seed),
        Collapse(CollapsableInternal),
    }

    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> result_stack: Vec<span style="color:#f92672">&lt;</span>Out<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[];
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> stack <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[State::Expand(seed)];

    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(item) <span style="color:#f92672">=</span> stack.pop() {
        <span style="color:#66d9ef">match</span> item {
            State::Expand(seed) <span style="color:#f92672">=&gt;</span> {
                <span style="color:#66d9ef">let</span> node <span style="color:#f92672">=</span> expand_layer(seed);
                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> seeds <span style="color:#f92672">=</span> Vec::new();
                <span style="color:#66d9ef">let</span> node <span style="color:#f92672">=</span> node.map_layer(<span style="color:#f92672">|</span>seed<span style="color:#f92672">|</span> {
                    seeds.push(seed);
                    ()
                });

                stack.push(State::Collapse(node));
                stack.extend(seeds.into_iter().map(State::Expand));
            }
            State::Collapse(node) <span style="color:#f92672">=&gt;</span> {
                <span style="color:#66d9ef">let</span> node <span style="color:#f92672">=</span> node.map_layer(<span style="color:#f92672">|</span>_: ()<span style="color:#f92672">|</span> result_stack.pop().unwrap());
                result_stack.push(collapse_layer(node))
            }
        };
    }
    result_stack.pop().unwrap()
}
</code></pre></div><p>This is <em>fully generic</em>, and can be used with any recursive structure. In the next post, I'll show how to use it to build an expression language for matching filesystem entities, with features like short-circuiting to minimize syscalls, arena allocation (as a flex), and, of course, many more execution graphs.</p>
<h1 id="thank-you">Thank you<a href="#thank-you" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Thank you to <a href="https://twitter.com/munin">Fiona</a> and <a href="https://twitter.com/sunshowers6">Rain</a>, among others, for reviewing drafts of this post.</p>
      </div></div>

  
  
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        <span class="button previous">
            <a href="https://recursion.wtf/posts/transitive-frontier/">
                <span class="button__icon">←</span>
                <span class="button__text">Transitive Frontier</span>
            </a>
        </span>
        
        
    </div>
</div>

  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2022 Powered by <a href="http://gohugo.io">Hugo</a></span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="https://recursion.wtf/assets/main.js"></script>
<script src="https://recursion.wtf/assets/prism.js"></script>







  
</div>

</body>
</html>
