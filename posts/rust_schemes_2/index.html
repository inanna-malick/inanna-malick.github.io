<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Fully generic recursion in Rust :: [ recursion.wtf ]</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="This is the second in a series of blog posts. Previously, we introduced a method for writing performant stack safe recursion in Rust for a single recursive data structure. This post covers the core ideas used to implement a single recursion backend that can handle collapsing or expanding any user-defined recursive data structure.
" />
<meta name="keywords" content="recursion schemes, rust, code" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://recursion.wtf/posts/rust_schemes_2/" />




<link rel="stylesheet" href="https://recursion.wtf/assets/style.css">

  <link rel="stylesheet" href="https://recursion.wtf/assets/blue.css">






<link rel="apple-touch-icon" href="https://recursion.wtf/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="https://recursion.wtf/img/favicon/blue.png">



<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="inanna_malick" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Fully generic recursion in Rust">
<meta property="og:description" content="This is the second in a series of blog posts. Previously, we introduced a method for writing performant stack safe recursion in Rust for a single recursive data structure. This post covers the core ideas used to implement a single recursion backend that can handle collapsing or expanding any user-defined recursive data structure.
" />
<meta property="og:url" content="https://recursion.wtf/posts/rust_schemes_2/" />
<meta property="og:site_name" content="[ recursion.wtf ]" />

  <meta property="og:image" content="https://recursion.wtf/img/rust_schemes/criterion_screenshot_preview.png">

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2002-07-24 00:00:00 &#43;0000 UTC" />












</head>
<body class="blue">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Inanna Malick
  </div>
</a>

    </div>
    
      <div class="menu-trigger">menu</div>
    
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="https://github.com/inanna-malick/">Github</a></li>
        
      
        
          <li><a href="https://twitter.com/inanna_malick">Twitter</a></li>
        
      
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="https://github.com/inanna-malick/">Github</a></li>
      
    
      
        <li><a href="https://twitter.com/inanna_malick">Twitter</a></li>
      
    
    
  </ul>
</nav>

  

  <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://recursion.wtf/img/rust_schemes/criterion_screenshot_preview.png"/>

<meta name="twitter:title" content="Fully generic recursion in Rust"/>
<meta name="twitter:description" content="This is the second in a series of blog posts. Previously, we introduced a method for writing performant stack safe recursion in Rust for a single recursive data structure. This post covers the core ideas used to implement a single recursion backend that can handle collapsing or expanding any user-defined recursive data structure."/>

  <meta property="og:title" content="Fully generic recursion in Rust" />
<meta property="og:description" content="This is the second in a series of blog posts. Previously, we introduced a method for writing performant stack safe recursion in Rust for a single recursive data structure. This post covers the core ideas used to implement a single recursion backend that can handle collapsing or expanding any user-defined recursive data structure." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://recursion.wtf/posts/rust_schemes_2/" />
<meta property="og:image" content="https://recursion.wtf/img/rust_schemes/criterion_screenshot_preview.png" />
<meta property="article:published_time" content="2002-07-24T00:00:00+00:00" />
<meta property="article:modified_time" content="2002-07-24T00:00:00+00:00" /><meta property="og:site_name" content="[ recursion.wtf ]" />



</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://recursion.wtf/posts/rust_schemes_2/">Fully generic recursion in Rust</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2002-07-24 
      </span>
    
    
    <span class="post-author">:: Inanna Malick</span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="https://recursion.wtf/tags/recursion-schemes/">recursion schemes</a>&nbsp;
    
    #<a href="https://recursion.wtf/tags/rust/">rust</a>&nbsp;
    
    #<a href="https://recursion.wtf/tags/code/">code</a>&nbsp;
    
    #<a href="https://recursion.wtf/tags/generic/">generic</a>&nbsp;
    
  </span>
  

  
  

  

  <div class="post-content"><div>
        <p>This is the second in a series of blog posts. Previously, we introduced a method for writing performant stack safe recursion in Rust for a single recursive data structure. This post covers the core ideas used to implement a <em>single</em> recursion backend that can handle collapsing or expanding any user-defined recursive data structure.</p>
<p>This generic recursion backend is implemented in my new <a href="https://crates.io/crates/recursion">recursion</a> crate. Docs are <a href="https://docs.rs/recursion">here</a>. Source code, along with examples and benchmarks, <a href="https://github.com/inanna-malick/recursion">can be found here</a>.</p>
<h1 id="a-recap">A Recap<a href="#a-recap" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p><a href="https://recursion.wtf/posts/rust_schemes/">Last time</a>, we implemented <code>collapse_layers</code> and <code>expand_layers</code><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> functions, specialized to <code>ExprTopo</code>.</p>
<p>​We're going to start by looking at our <code>ExprTopo::collapse_layers</code> function from the last post. Note that it's specialized for use with <code>ExprLayer</code>. We explored the impl in detail last time, so we're going to elide that, and just look at the types:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ExprIdx</span>(<span style="color:#66d9ef">usize</span>);

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ExprTopo</span> {
    <span style="color:#75715e">// nonempty, in topological-sorted order. guaranteed via construction.
</span><span style="color:#75715e"></span>    elems: Vec<span style="color:#f92672">&lt;</span>ExprLayer<span style="color:#f92672">&lt;</span>ExprIdx<span style="color:#f92672">&gt;&gt;</span>,
}

<span style="color:#66d9ef">impl</span> ExprTopo {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">collapse_layers</span><span style="color:#f92672">&lt;</span>F: FnMut(ExprLayer<span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">A</span><span style="color:#f92672">&gt;</span>(self, <span style="color:#66d9ef">mut</span> collapse_layer: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">A</span> {
        <span style="color:#75715e">/* see previous post for full impl */</span>
    }
}
</code></pre></div><p>It's generic in one way - it can take any function <code>ExprLayer&lt;A&gt; -&gt; A</code> and use it to collapse an <code>ExprTopo</code> down to a single value. But it's still tied, explicitly, to <code>ExprTopo</code>. It would be better if we only had to write this function once, instead of once per data structure. That way, we can focus on optimizing that function, and can closely analyze it for correctness (instead of having to write it multiple times, at the risk of introducing subtle errors in boilerplate code).</p>
<h1 id="a-more-generic-collapse">A more Generic collapse<a href="#a-more-generic-collapse" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Here's what we want our generic <code>collapse_layers</code> function to look like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#e6db74">/// Support for collapsing a data structure into a single value, one layer at a time
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Collapse<span style="color:#f92672">&lt;</span>A, Wrapped<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">collapse_layers</span><span style="color:#f92672">&lt;</span>F: FnMut(Wrapped) -&gt; <span style="color:#a6e22e">A</span><span style="color:#f92672">&gt;</span>(self, collapse_layer: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">A</span>;
}
</code></pre></div><p>This should be read as being parameterized over some type <code>Layer</code>, with <code>Wrapped</code> being <code>Layer&lt;A&gt;</code><sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>. <code>A</code> is just the type we're collapsing the data structure down into.</p>
<p>While we're at it, let's put together a trait for expanding a recursive data structure from some seed:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#e6db74">/// Support for expanding a data structure from a seed value, one layer at a time
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Expand<span style="color:#f92672">&lt;</span>A, Wrapped<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">expand_layers</span><span style="color:#f92672">&lt;</span>F: Fn(A) -&gt; <span style="color:#a6e22e">Wrapped</span><span style="color:#f92672">&gt;</span>(a: <span style="color:#a6e22e">A</span>, expand_layer: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Self</span>;
}
</code></pre></div><p>Now that we have these traits, we can represent the generic ability to collapse or expand <em>arbitrary</em> recursive data structures, we just need to figure out how to implement them.</p>
<h1 id="but-how">But how?<a href="#but-how" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p><a href="https://recursion.wtf/posts/rust_schemes/#factoring-out-duplicated-code">In the last post</a>, we saw how <code>ExprLayer::map</code> could be used to factor out the core logic of <code>collapse_layers</code> and <code>expand_layers</code>. We're going to abstract over this, such that we can map over a single layer of any recursive data structure, instead of just <code>ExprLayer&lt;_&gt;</code>. To do this, we're going to introduce a trait called <code>MapLayer</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#e6db74">/// The ability to map over some a single layer of some structure
</span><span style="color:#e6db74">/// &#39;Layer&lt;_&gt;&#39;, eg &#39;ExprLayer&lt;_&gt;&#39;.
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> MapLayer<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> { <span style="color:#75715e">// where Self is Layer&lt;A&gt;
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Unwrapped</span>;    <span style="color:#75715e">// which is A
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">To</span>;           <span style="color:#75715e">// which is Layer&lt;B&gt;
</span><span style="color:#75715e"></span>    <span style="color:#e6db74">/// fn map_layer(Self: Layer&lt;A&gt;, f: Fn(A) -&gt; B) -&gt; Layer&lt;B&gt;
</span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">map_layer</span><span style="color:#f92672">&lt;</span>F: FnMut(Self::Unwrapped) -&gt; <span style="color:#a6e22e">B</span><span style="color:#f92672">&gt;</span>(self, f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Self</span>::To;
}
</code></pre></div><p>You should read this as being implemented for some <code>Layer&lt;_&gt;</code> (eg <code>ExprLayer&lt;_&gt;</code>) with the (pseudocode) type signature <code>fn map_layer(self: Layer&lt;A&gt;, f: Fn(A) -&gt; B) -&gt; Layer&lt;B&gt;</code>.</p>
<p>And here it is <sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></p>
<p>Here's what it looks like as implemented for <code>ExprLayer&lt;_&gt;</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>A, B<span style="color:#f92672">&gt;</span> MapLayer<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> ExprLayer<span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">To</span> <span style="color:#f92672">=</span> ExprLayer<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>;
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Unwrapped</span> <span style="color:#f92672">=</span> A;

    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">map_layer</span><span style="color:#f92672">&lt;</span>F: FnMut(Self::Unwrapped) -&gt; <span style="color:#a6e22e">B</span><span style="color:#f92672">&gt;</span>(self, <span style="color:#66d9ef">mut</span> f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Self</span>::To {
        <span style="color:#66d9ef">match</span> self {
            Expr::Add(a, b) <span style="color:#f92672">=&gt;</span> Expr::Add(f(a), f(b)),
            Expr::Sub(a, b) <span style="color:#f92672">=&gt;</span> Expr::Sub(f(a), f(b)),
            Expr::Mul(a, b) <span style="color:#f92672">=&gt;</span> Expr::Mul(f(a), f(b)),
            Expr::LiteralInt(x) <span style="color:#f92672">=&gt;</span> Expr::LiteralInt(x),
        }
    }
}
</code></pre></div><p>Some boilerplate, nothing too complex.</p>
<h1 id="implementing-the-collapse-and-expand-traits">Implementing the Collapse and Expand traits<a href="#implementing-the-collapse-and-expand-traits" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>We'll be implementing <code>Collapse</code> and <code>Expand</code> for this data structure:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#e6db74">/// Index into the vector of elements
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Index</span>(<span style="color:#66d9ef">usize</span>);

<span style="color:#e6db74">/// Recursive tree made up of layers of some type &#39;Layer&lt;_&gt;&#39;, eg `ExprLayer&lt;_&gt;`
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">RecursiveTree</span><span style="color:#f92672">&lt;</span>Wrapped<span style="color:#f92672">&gt;</span> {
    <span style="color:#e6db74">/// nonempty, in topological-sorted order
</span><span style="color:#e6db74"></span>    elems: Vec<span style="color:#f92672">&lt;</span>Wrapped<span style="color:#f92672">&gt;</span>, <span style="color:#75715e">// Layer&lt;Index&gt; (eg `Layer&lt;_&gt;`)
</span><span style="color:#75715e"></span>}
</code></pre></div><p><code>Index</code> is a generic version of the <code>ExprIndex</code> used in the previous post - it's an internal index used to track links between different layers of the <code>RecursiveTree</code>.</p>
<p>Here's what <code>ExprTopo</code> would look like using <code>RecursiveTree</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ExprTopo</span> <span style="color:#f92672">=</span> RecursiveTree<span style="color:#f92672">&lt;</span>ExprLayer<span style="color:#f92672">&lt;</span>Index<span style="color:#f92672">&gt;&gt;</span>
</code></pre></div><h2 id="collapse">Collapse<a href="#collapse" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Here's what the implementation of <code>Collapse</code> looks like. I've elided the internal machinery so we can focus on the types - the full source code is <a href="https://github.com/inanna-malick/recursion/blob/main/src/recursive_tree/arena_eval.rs#L96-L127">here</a>, but since it's fully generic you can just use the crate, there's no need to ever implement it yourself.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>A, Wrapped, Underlying<span style="color:#f92672">&gt;</span> Collapse<span style="color:#f92672">&lt;</span>A, Wrapped<span style="color:#f92672">&gt;</span>
    <span style="color:#66d9ef">for</span> RecursiveTree<span style="color:#f92672">&lt;</span>Underlying<span style="color:#f92672">&gt;</span>
    <span style="color:#66d9ef">where</span>
            Underlying: <span style="color:#a6e22e">MapLayer</span><span style="color:#f92672">&lt;</span>A, To <span style="color:#f92672">=</span> Wrapped, Unwrapped <span style="color:#f92672">=</span> Index<span style="color:#f92672">&gt;</span>
{
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">collapse_layers</span><span style="color:#f92672">&lt;</span>F: FnMut(Wrapped) -&gt; <span style="color:#a6e22e">A</span><span style="color:#f92672">&gt;</span>(self, <span style="color:#66d9ef">mut</span> collapse_layer: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">A</span> {
        <span style="color:#75715e">/* elided */</span>
    }
}
</code></pre></div><p>This is very similar to the <code>ExprTopo::collapse_layers</code> function <a href="https://recursion.wtf/posts/rust_schemes/#making-it-generic">in the previous post</a>, and all we need is a <code>MapLayer</code>!</p>
<p>Here's what it looks like in use:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">eval</span>(expr: <span style="color:#a6e22e">ExprTopo</span>) -&gt; <span style="color:#66d9ef">i64</span> {
    self.collapse_layers(<span style="color:#f92672">|</span>expr<span style="color:#f92672">|</span> <span style="color:#66d9ef">match</span> expr {
        ExprLayer::Add { a, b } <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">+</span> b,
        ExprLayer::Sub { a, b } <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">-</span> b,
        ExprLayer::Mul { a, b } <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">*</span> b,
        ExprLayer::LiteralInt { literal } <span style="color:#f92672">=&gt;</span> literal,
    })
}
</code></pre></div><h2 id="expand">Expand<a href="#expand" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Here's what expanding this data structure from a seed value looks like. As before, I've elided the implementation. If you're curious, the full source code is <a href="https://github.com/inanna-malick/recursion/blob/main/src/recursive_tree/arena_eval.rs#L26-L52">here</a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>A, Underlying, Wrapped<span style="color:#f92672">&gt;</span> Expand<span style="color:#f92672">&lt;</span>A, Wrapped<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> RecursiveTree<span style="color:#f92672">&lt;</span>Underlying<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">where</span>
    Wrapped: <span style="color:#a6e22e">MapLayer</span><span style="color:#f92672">&lt;</span>Index, Unwrapped <span style="color:#f92672">=</span> A, To <span style="color:#f92672">=</span> Underlying<span style="color:#f92672">&gt;</span>,
{
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">expand_layers</span><span style="color:#f92672">&lt;</span>F: Fn(A) -&gt; <span style="color:#a6e22e">Wrapped</span><span style="color:#f92672">&gt;</span>(a: <span style="color:#a6e22e">A</span>, expand_layer: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Self</span> {
        <span style="color:#75715e">/* elided */</span>
    }
}
</code></pre></div><p>Very similar to the <code>ExprTopo::expand_layers</code> function <a href="https://recursion.wtf/posts/rust_schemes/#making-it-generic-1">in the previous post</a>, but over <em>some generic structure</em>. Just to verify, let's write a function to expand out an <code>ExprTopo</code> from a boxed expression, just as we did in the last post. But this time, it's generic:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">from_boxed</span>(ast: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">ExprBoxed</span>) -&gt; <span style="color:#a6e22e">ExprTopo</span> {
    ExprTopo::expand(ast, <span style="color:#f92672">|</span>seed<span style="color:#f92672">|</span> <span style="color:#66d9ef">match</span> seed {
        ExprBoxed::Add { a, b } <span style="color:#f92672">=&gt;</span> ExprLayer::Add { a, b },
        ExprBoxed::Sub { a, b } <span style="color:#f92672">=&gt;</span> ExprLayer::Sub { a, b },
        ExprBoxed::Mul { a, b } <span style="color:#f92672">=&gt;</span> ExprLayer::Mul { a, b },
        ExprBoxed::LiteralInt { literal } <span style="color:#f92672">=&gt;</span> ExprLayer::LiteralInt { literal: <span style="color:#f92672">*</span>literal },
    })
}
</code></pre></div><p>Nice.</p>
<p>These pass all the same tests as the <code>Expr</code>-specialized <code>collapse_layers</code>/<code>expand_layers</code> functions, but we only have to write the machinery of recursion once! Not once per recursive data structure, just once! <sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup></p>
<p>Just as before, I want to emphasize that this is fully generic over <em>any</em> recursive data structure:</p>
<h1 id="a-minimal-example">A minimal example<a href="#a-minimal-example" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>For the last section of this blog post, we're going to use the machinery we've built up to implement another data structure: an N-tree. An N-tree is a tree where each node can have any number of child nodes, and where some value <code>V</code> is stored at each node of the tree. Nodes with no child nodes are leaf nodes.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">NTreeLayer</span><span style="color:#f92672">&lt;</span>Val, A<span style="color:#f92672">&gt;</span> {
    val: <span style="color:#a6e22e">Val</span>,
    children: Vec<span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span>,
}

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RecursiveNTree</span><span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> RecursiveTree<span style="color:#f92672">&lt;</span>NTreeLayer<span style="color:#f92672">&lt;</span>V, Index<span style="color:#f92672">&gt;&gt;</span>;

<span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>A, B, V<span style="color:#f92672">&gt;</span> MapLayer<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> NTreeLayer<span style="color:#f92672">&lt;</span>V, A<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">To</span> <span style="color:#f92672">=</span> NTreeLayer<span style="color:#f92672">&lt;</span>V, B<span style="color:#f92672">&gt;</span>;
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Unwrapped</span> <span style="color:#f92672">=</span> A;

    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">map_layer</span><span style="color:#f92672">&lt;</span>F: FnMut(Self::Unwrapped) -&gt; <span style="color:#a6e22e">B</span><span style="color:#f92672">&gt;</span>(self, f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Self</span>::To {
        Self::To {
            val: <span style="color:#a6e22e">self</span>.val,
            children: <span style="color:#a6e22e">self</span>.children.into_iter().map(f).collect(),
        }
    }
}
</code></pre></div><p>This is pretty good, not much boilerplate!</p>
<p>Here's some simple functions over our N-tree:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">depth</span><span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span>(r: <span style="color:#a6e22e">RecursiveNTree</span><span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#66d9ef">usize</span> {
    r.collapse_layers(<span style="color:#f92672">|</span>layer<span style="color:#f92672">|</span> layer.children.iter().max().map_or(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">|</span>n<span style="color:#f92672">|</span> n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>))
}

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">max</span><span style="color:#f92672">&lt;</span>V: Ord<span style="color:#f92672">&gt;</span>(r: <span style="color:#a6e22e">RecursiveNTree</span><span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span>) -&gt; Option<span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> {
    r.collapse_layers(<span style="color:#f92672">|</span>layer<span style="color:#f92672">|</span> layer.children.into_iter().filter_map(<span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> x).max())
}
</code></pre></div><p>Cool, right?</p>
<h1 id="async-io">Async IO<a href="#async-io" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>I've also used my crate to implement a small but fully functional filetree reader/file contents search tool example. It's fully async, with all the bells and whistles one might expect. <sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>. <a href="https://github.com/inanna-malick/recursion/blob/main/examples/grep.rs">You can find the source code here.</a>.</p>
<pre><font color="#A6CC70"><b>➜ </b></font>./my_grep -- --regex &quot;Expr.*Sub&quot; --paths-to-ignore .git -p target
<font color="#95E6CB">sparse filetree depth:</font> 4
<font color="#95E6CB">file:</font> &quot;/home/inanna/dev/rust-schemes/src/examples/expr.rs&quot;
<font color="#95E6CB">permissions</font> Permissions(FilePermissions { mode: 33204 })
<font color="#95E6CB">modified</font> Ok(SystemTime { tv_sec: 1658530322, tv_nsec: 155879740 })
<font color="#B48EAD">29::</font>	            Expr::Sub(a, b) =&gt; Expr::Sub(f(a), f(b)),
<font color="#B48EAD">45::</font>	            Expr::Sub(a, b) =&gt; Expr::Sub(f(*a), f(*b)),


<font color="#95E6CB">file:</font> &quot;/home/inanna/dev/rust-schemes/src/examples/expr/eval.rs&quot;
<font color="#95E6CB">permissions</font> Permissions(FilePermissions { mode: 33204 })
<font color="#95E6CB">modified</font> Ok(SystemTime { tv_sec: 1658527781, tv_nsec: 256109881 })
<font color="#B48EAD">54::</font>	        Expr::Sub(a, b) =&gt; Ok(CompiledExpr::Sub(a, b)),
<font color="#B48EAD">70::</font>	        CompiledExpr::Sub(a, b) =&gt; a - b,
<font color="#B48EAD">80::</font>	        Expr::Sub(a, b) =&gt; a - b,
<font color="#B48EAD">89::</font>	        ExprAST::Sub(a, b) =&gt; naive_eval(a) - naive_eval(b),
</pre>
<h1 id="to-be-continued">To be continued<a href="#to-be-continued" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>My next post will show how to implement different recursion backends (yes, this is where we finally get to see stack machines in action), along with some cool stuff with fused <code>expand_layers</code> and <code>collapse_layers</code> operations such that we can construct a recursive data structure and consume it at the same time, without having to allocate a <code>RecursiveTree</code>.</p>
<h1 id="thank-you">Thank you<a href="#thank-you" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Thank you to <a href="https://twitter.com/munin">Fiona</a>, <a href="https://twitter.com/sunshowers6">Rain</a>, <a href="https://twitter.com/mycoliza">Eliza</a>, among others, for reviewing drafts of this post.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>If you're a recursion schemes nerd like me, you might notice that these correspond to catamorphism (a collapsing change) and anamorphism (an expanding change), but with less greek. They don't sound as cool, but I think they're a more readable representation of the same concept. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>In a perfect word, we could parameterize this over the <code>Layer</code> type (such as <code>ExprLayer</code>), but in Rust all types need to be fully applied, so we need to use <code>Wrapped</code> instead, to represent the fully applied <code>Layer&lt;A&gt;</code> type. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>If you're a functional programming nerd like me, you might recognize this as 'Functor' <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>a bolt of lightning strikes behind me. I am momentarily shown silhouetted by the actinic blue light. It is very dramatic <a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p>ok, so it just uses <code>tokio::fs</code> (which just calls std lib blocking functions to work with the file system) instead of something hand crafted with manual file handle management, but there's a good reason I didn't implement that: I didn't want to <a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
      </div></div>

  
  
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        <span class="button previous">
            <a href="https://recursion.wtf/posts/transitive-frontier/">
                <span class="button__icon">←</span>
                <span class="button__text">Transitive Frontier</span>
            </a>
        </span>
        
        
    </div>
</div>

  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2022 Powered by <a href="http://gohugo.io">Hugo</a></span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="https://recursion.wtf/assets/main.js"></script>
<script src="https://recursion.wtf/assets/prism.js"></script>







  
</div>

</body>
</html>
