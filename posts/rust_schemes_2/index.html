

<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

 


      <title>Fully generic recursion in Rust - </title>

  <meta name="description" content="Previously, we introduced a method for writing performant stack safe recursion in Rust for a single recursive data structure. This post uses the same ideas to implement a single recursion backend that can collapse or expand any recursive data structure."><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "Inanna Malick",
    
    "url": "https:\/\/recursion.wtf\/"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/recursion.wtf\/"
  
  
  
  
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "item": {
          "@id": "https:\/\/recursion.wtf\/",
          "name": "home"
        }
    },{
        "@type": "ListItem",
        "position": 3,
        "item": {
          "@id": "https:\/\/recursion.wtf\/posts\/rust_schemes_2\/",
          "name": "Fully generic recursion in rust"
        }
    }]
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "author": {
    "name" : "Inanna Malick"
  },
  "headline": "Fully generic recursion in Rust",
  "description" : "Previously, we introduced a method for writing performant stack safe recursion in Rust for a single recursive data structure. This post uses the same ideas to implement a single recursion backend that can collapse or expand any recursive data structure.\n",
  "inLanguage" : "en",
  "wordCount":  1502 ,
  "datePublished" : "2022-07-28T00:00:00\u002b00:00",
  "dateModified" : "2022-07-28T00:00:00\u002b00:00",
  "image" : "https:\/\/recursion.wtf\/img\/avatar-icon.png",
  "keywords" : [ "recursion schemes, rust, code, generic" ],
  "mainEntityOfPage" : "https:\/\/recursion.wtf\/posts\/rust_schemes_2\/",
  "publisher" : {
    "@type": "Organization",
    "name" : "https:\/\/recursion.wtf\/",
    "logo" : {
        "@type" : "ImageObject",
        "url" : "https:\/\/recursion.wtf\/img\/avatar-icon.png",
        "height" :  60 ,
        "width" :  60
    }
  }
}
</script>


<meta property="og:title" content="Fully generic recursion in Rust" />
<meta property="og:description" content="Previously, we introduced a method for writing performant stack safe recursion in Rust for a single recursive data structure. This post uses the same ideas to implement a single recursion backend that can collapse or expand any recursive data structure.">
<meta property="og:url" content="https://recursion.wtf/posts/rust_schemes_2/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="Inanna Malick" />

  <meta name="twitter:title" content="Fully generic recursion in Rust" />
  <meta name="twitter:description" content="Previously, we introduced a method for writing performant stack safe recursion in Rust for a single recursive data structure. This post uses the same ideas to implement a single recursion backend that …">
  <meta name="twitter:image" content="https://recursion.wtf/img/avatar-icon.png" />
  <meta name="twitter:card" content="summary_large_image" />
  <link href='https://recursion.wtf/img/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta name="generator" content="Hugo 0.147.8">
  <link rel="alternate" href="https://recursion.wtf/index.xml" type="application/rss+xml" title="Inanna Malick"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css" integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.6.0/css/all.css" integrity="sha384-h/hnnw1Bi4nbpD6kE7nYfCXzovi622sY5WBxww8ARKwpdLj5kUWjRuyiXaD1U2JT" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css" integrity="sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu" crossorigin="anonymous"><link rel="stylesheet" href="https://recursion.wtf/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" /><link rel="stylesheet" href="https://recursion.wtf/css/syntax.css" /><link rel="stylesheet" href="https://recursion.wtf/css/codeblock.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous"><link rel="stylesheet" href="https://recursion.wtf/css/style.css">
  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://recursion.wtf/">Inanna Malick</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="Tags" href="/tags">Tags</a>
            </li>
          
        

        

        
      </ul>
    </div>

    
      <div class="avatar-container">
        <div class="avatar-img-border">
          <a title="Inanna Malick" href="https://recursion.wtf/">
            <img class="avatar-img" src="https://recursion.wtf/img/avatar-icon.png" alt="Inanna Malick" />
           
          </a>
        </div>
      </div>
    

  </div>
</nav>




    


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>


  
  
  






  

  <header class="header-section ">
    
    
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="posts-heading">
              
                <h1>Fully generic recursion in Rust</h1>
              
              
                <hr class="small">
              
              
              
            </div>
          </div>
        </div>
      </div>
    </div>
  
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        <p><a href="https://recursion.wtf/posts/rust_schemes/">Previously</a>, we introduced a method for writing performant stack safe recursion in Rust for a single recursive data structure. This post uses the same ideas to implement a <em>single</em> recursion backend that can collapse or expand any recursive data structure.</p>
<p>This generic recursion backend is implemented in my new <a href="https://crates.io/crates/recursion">recursion</a> crate. Docs are <a href="https://docs.rs/recursion">here</a>. Source code, along with examples and benchmarks, <a href="https://github.com/inanna-malick/recursion">can be found here</a>.</p>
<h1 id="a-recap">A Recap</h1>
<p><a href="https://recursion.wtf/posts/rust_schemes/">Last time</a>, we implemented <code>collapse_layers</code> and <code>expand_layers</code><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> functions, specialized to <code>ExprTopo</code>.</p>
<p>​We&rsquo;re going to start by looking at our <code>ExprTopo::collapse_layers</code> function from the last post. Note that it&rsquo;s specialized for use with <code>ExprLayer</code>. We explored the impl in detail last time, so we&rsquo;re going to elide that, and just look at the types:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ExprIdx</span>(<span style="color:#66d9ef">usize</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ExprTopo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// nonempty, in topological-sorted order. guaranteed via construction.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    elems: Vec<span style="color:#f92672">&lt;</span>ExprLayer<span style="color:#f92672">&lt;</span>ExprIdx<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> ExprTopo {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">collapse_layers</span><span style="color:#f92672">&lt;</span>F: FnMut(ExprLayer<span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">A</span><span style="color:#f92672">&gt;</span>(self, <span style="color:#66d9ef">mut</span> collapse_layer: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* see previous post for full impl */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It&rsquo;s generic in one way - it can take any function <code>ExprLayer&lt;A&gt; -&gt; A</code> and use it to collapse an <code>ExprTopo</code> down to a single value. But it&rsquo;s still tied, explicitly, to <code>ExprTopo</code>. It would be better if we only had to write this function once, instead of once per data structure. That way, we can focus on optimizing that function, and can closely analyze it for correctness (instead of having to write it multiple times, at the risk of introducing subtle errors in boilerplate code).</p>
<h1 id="a-more-generic-collapse">A more Generic collapse</h1>
<p>Here&rsquo;s what we want our generic <code>collapse_layers</code> function to look like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#e6db74">/// Support for collapsing a data structure into a single value, one layer at a time
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Collapse<span style="color:#f92672">&lt;</span>A, Wrapped<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">collapse_layers</span><span style="color:#f92672">&lt;</span>F: FnMut(Wrapped) -&gt; <span style="color:#a6e22e">A</span><span style="color:#f92672">&gt;</span>(self, collapse_layer: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">A</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This should be read as being parameterized over some type <code>Layer</code>, with <code>Wrapped</code> being <code>Layer&lt;A&gt;</code><sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>. <code>A</code> is just the type we&rsquo;re collapsing the data structure down into.</p>
<p>While we&rsquo;re at it, let&rsquo;s put together a trait for expanding a recursive data structure from some seed:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#e6db74">/// Support for expanding a data structure from a seed value, one layer at a time
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Expand<span style="color:#f92672">&lt;</span>A, Wrapped<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">expand_layers</span><span style="color:#f92672">&lt;</span>F: Fn(A) -&gt; <span style="color:#a6e22e">Wrapped</span><span style="color:#f92672">&gt;</span>(a: <span style="color:#a6e22e">A</span>, expand_layer: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Self</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now that we have these traits, we can represent the generic ability to collapse or expand <em>arbitrary</em> recursive data structures, we just need to figure out how to implement them.</p>
<h1 id="but-how">But how?</h1>
<p><a href="https://recursion.wtf/posts/rust_schemes/#factoring-out-duplicated-code">In the last post</a>, we saw how <code>ExprLayer::map</code> could be used to factor out the core logic of <code>collapse_layers</code> and <code>expand_layers</code>. We&rsquo;re going to abstract over this, such that we can map over a single layer of any recursive data structure, instead of just <code>ExprLayer&lt;_&gt;</code>. To do this, we&rsquo;re going to introduce a trait called <code>MapLayer</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#e6db74">/// The ability to map over some a single layer of some structure
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// &#39;Layer&lt;_&gt;&#39;, eg &#39;ExprLayer&lt;_&gt;&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> MapLayer<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> { <span style="color:#75715e">// where Self is Layer&lt;A&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Unwrapped</span>;    <span style="color:#75715e">// which is A
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">To</span>;           <span style="color:#75715e">// which is Layer&lt;B&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">/// fn map_layer(Self: Layer&lt;A&gt;, f: Fn(A) -&gt; B) -&gt; Layer&lt;B&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">map_layer</span><span style="color:#f92672">&lt;</span>F: FnMut(Self::Unwrapped) -&gt; <span style="color:#a6e22e">B</span><span style="color:#f92672">&gt;</span>(self, f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Self</span>::To;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You should read this as being implemented for some <code>Layer&lt;_&gt;</code> (eg <code>ExprLayer&lt;_&gt;</code>) with the (pseudocode) type signature <code>fn map_layer(self: Layer&lt;A&gt;, f: Fn(A) -&gt; B) -&gt; Layer&lt;B&gt;</code>.</p>
<p>And here it is <sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></p>
<p>Here&rsquo;s what it looks like as implemented for <code>ExprLayer&lt;_&gt;</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>A, B<span style="color:#f92672">&gt;</span> MapLayer<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> ExprLayer<span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">To</span> <span style="color:#f92672">=</span> ExprLayer<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Unwrapped</span> <span style="color:#f92672">=</span> A;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">map_layer</span><span style="color:#f92672">&lt;</span>F: FnMut(Self::Unwrapped) -&gt; <span style="color:#a6e22e">B</span><span style="color:#f92672">&gt;</span>(self, <span style="color:#66d9ef">mut</span> f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Self</span>::To {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self {
</span></span><span style="display:flex;"><span>            Expr::Add(a, b) <span style="color:#f92672">=&gt;</span> Expr::Add(f(a), f(b)),
</span></span><span style="display:flex;"><span>            Expr::Sub(a, b) <span style="color:#f92672">=&gt;</span> Expr::Sub(f(a), f(b)),
</span></span><span style="display:flex;"><span>            Expr::Mul(a, b) <span style="color:#f92672">=&gt;</span> Expr::Mul(f(a), f(b)),
</span></span><span style="display:flex;"><span>            Expr::LiteralInt(x) <span style="color:#f92672">=&gt;</span> Expr::LiteralInt(x),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Some boilerplate, nothing too complex.</p>
<h1 id="implementing-the-collapse-and-expand-traits">Implementing the Collapse and Expand traits</h1>
<p>We&rsquo;ll be implementing <code>Collapse</code> and <code>Expand</code> for this data structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#e6db74">/// Index into the vector of elements
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Index</span>(<span style="color:#66d9ef">usize</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// Recursive tree made up of layers of some type &#39;Layer&lt;_&gt;&#39;, eg `ExprLayer&lt;_&gt;`
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">RecursiveTree</span><span style="color:#f92672">&lt;</span>Wrapped<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// nonempty, in topological-sorted order
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    elems: Vec<span style="color:#f92672">&lt;</span>Wrapped<span style="color:#f92672">&gt;</span>, <span style="color:#75715e">// Layer&lt;Index&gt; (eg `ExprLayer&lt;Index&gt;`)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><code>Index</code> is a generic version of the <code>ExprIndex</code> used in the previous post - it&rsquo;s an internal index used to track links between different layers of the <code>RecursiveTree</code>.</p>
<p>Here&rsquo;s what <code>ExprTopo</code> would look like using <code>RecursiveTree</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ExprTopo</span> <span style="color:#f92672">=</span> RecursiveTree<span style="color:#f92672">&lt;</span>ExprLayer<span style="color:#f92672">&lt;</span>Index<span style="color:#f92672">&gt;&gt;</span>
</span></span></code></pre></div><h2 id="collapse">Collapse</h2>
<p>Here&rsquo;s what the implementation of <code>Collapse</code> looks like. I&rsquo;ve elided the internal machinery so we can focus on the types - the full source code is <a href="https://github.com/inanna-malick/recursion/blob/main/src/recursive_tree/arena_eval.rs#L96-L127">here</a>, but since it&rsquo;s fully generic you can just use the crate, there&rsquo;s no need to ever implement it yourself.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>A, Wrapped, Underlying<span style="color:#f92672">&gt;</span> Collapse<span style="color:#f92672">&lt;</span>A, Wrapped<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> RecursiveTree<span style="color:#f92672">&lt;</span>Underlying<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>            Underlying: <span style="color:#a6e22e">MapLayer</span><span style="color:#f92672">&lt;</span>A, To <span style="color:#f92672">=</span> Wrapped, Unwrapped <span style="color:#f92672">=</span> Index<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">collapse_layers</span><span style="color:#f92672">&lt;</span>F: FnMut(Wrapped) -&gt; <span style="color:#a6e22e">A</span><span style="color:#f92672">&gt;</span>(self, <span style="color:#66d9ef">mut</span> collapse_layer: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* elided */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is very similar to the <code>ExprTopo::collapse_layers</code> function <a href="https://recursion.wtf/posts/rust_schemes/#making-it-generic">in the previous post</a>, and all we need is a <code>MapLayer</code>!</p>
<p>Here&rsquo;s what it looks like in use:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">eval</span>(expr: <span style="color:#a6e22e">ExprTopo</span>) -&gt; <span style="color:#66d9ef">i64</span> {
</span></span><span style="display:flex;"><span>    self.collapse_layers(<span style="color:#f92672">|</span>expr<span style="color:#f92672">|</span> <span style="color:#66d9ef">match</span> expr {
</span></span><span style="display:flex;"><span>        ExprLayer::Add { a, b } <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">+</span> b,
</span></span><span style="display:flex;"><span>        ExprLayer::Sub { a, b } <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">-</span> b,
</span></span><span style="display:flex;"><span>        ExprLayer::Mul { a, b } <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">*</span> b,
</span></span><span style="display:flex;"><span>        ExprLayer::LiteralInt { literal } <span style="color:#f92672">=&gt;</span> literal,
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="expand">Expand</h2>
<p>Here&rsquo;s what expanding this data structure from a seed value looks like. As before, I&rsquo;ve elided the implementation. If you&rsquo;re curious, the full source code is <a href="https://github.com/inanna-malick/recursion/blob/main/src/recursive_tree/arena_eval.rs#L26-L52">here</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>A, Underlying, Wrapped<span style="color:#f92672">&gt;</span> Expand<span style="color:#f92672">&lt;</span>A, Wrapped<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> RecursiveTree<span style="color:#f92672">&lt;</span>Underlying<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    Wrapped: <span style="color:#a6e22e">MapLayer</span><span style="color:#f92672">&lt;</span>Index, Unwrapped <span style="color:#f92672">=</span> A, To <span style="color:#f92672">=</span> Underlying<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">expand_layers</span><span style="color:#f92672">&lt;</span>F: Fn(A) -&gt; <span style="color:#a6e22e">Wrapped</span><span style="color:#f92672">&gt;</span>(a: <span style="color:#a6e22e">A</span>, expand_layer: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* elided */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Very similar to the <code>ExprTopo::expand_layers</code> function <a href="https://recursion.wtf/posts/rust_schemes/#making-it-generic-1">in the previous post</a>, but over <em>some generic structure</em>. Just to verify, let&rsquo;s write a function to expand out an <code>ExprTopo</code> from a boxed expression, just as we did in the last post. But this time, it&rsquo;s generic:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">from_boxed</span>(ast: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">ExprBoxed</span>) -&gt; <span style="color:#a6e22e">ExprTopo</span> {
</span></span><span style="display:flex;"><span>    ExprTopo::expand(ast, <span style="color:#f92672">|</span>seed<span style="color:#f92672">|</span> <span style="color:#66d9ef">match</span> seed {
</span></span><span style="display:flex;"><span>        ExprBoxed::Add { a, b } <span style="color:#f92672">=&gt;</span> ExprLayer::Add { a, b },
</span></span><span style="display:flex;"><span>        ExprBoxed::Sub { a, b } <span style="color:#f92672">=&gt;</span> ExprLayer::Sub { a, b },
</span></span><span style="display:flex;"><span>        ExprBoxed::Mul { a, b } <span style="color:#f92672">=&gt;</span> ExprLayer::Mul { a, b },
</span></span><span style="display:flex;"><span>        ExprBoxed::LiteralInt { literal } <span style="color:#f92672">=&gt;</span> ExprLayer::LiteralInt { literal: <span style="color:#f92672">*</span>literal },
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Nice.</p>
<p>These pass all the same tests as the <code>Expr</code>-specialized <code>collapse_layers</code>/<code>expand_layers</code> functions, but we only have to write the machinery of recursion once! Not once per recursive data structure, just once! <sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup></p>
<p>Just as before, I want to emphasize that this is fully generic over <em>any</em> recursive data structure:</p>
<h1 id="a-minimal-example">A minimal example</h1>
<p>For the last section of this blog post, we&rsquo;re going to use the machinery we&rsquo;ve built up to implement another data structure: an N-tree. An N-tree is a tree where each node can have any number of child nodes, and where some value <code>V</code> is stored at each node of the tree. Nodes with no child nodes are leaf nodes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">NTreeLayer</span><span style="color:#f92672">&lt;</span>Val, A<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    val: <span style="color:#a6e22e">Val</span>,
</span></span><span style="display:flex;"><span>    children: Vec<span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RecursiveNTree</span><span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> RecursiveTree<span style="color:#f92672">&lt;</span>NTreeLayer<span style="color:#f92672">&lt;</span>V, Index<span style="color:#f92672">&gt;&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>A, B, V<span style="color:#f92672">&gt;</span> MapLayer<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> NTreeLayer<span style="color:#f92672">&lt;</span>V, A<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">To</span> <span style="color:#f92672">=</span> NTreeLayer<span style="color:#f92672">&lt;</span>V, B<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Unwrapped</span> <span style="color:#f92672">=</span> A;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">map_layer</span><span style="color:#f92672">&lt;</span>F: FnMut(Self::Unwrapped) -&gt; <span style="color:#a6e22e">B</span><span style="color:#f92672">&gt;</span>(self, f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Self</span>::To {
</span></span><span style="display:flex;"><span>        Self::To {
</span></span><span style="display:flex;"><span>            val: <span style="color:#a6e22e">self</span>.val,
</span></span><span style="display:flex;"><span>            children: <span style="color:#a6e22e">self</span>.children.into_iter().map(f).collect(),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is pretty good, not much boilerplate!</p>
<p>Here&rsquo;s some simple functions over our N-tree:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">depth</span><span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span>(r: <span style="color:#a6e22e">RecursiveNTree</span><span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#66d9ef">usize</span> {
</span></span><span style="display:flex;"><span>    r.collapse_layers(<span style="color:#f92672">|</span>layer<span style="color:#f92672">|</span> layer.children.iter().max().map_or(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">|</span>n<span style="color:#f92672">|</span> n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">max</span><span style="color:#f92672">&lt;</span>V: Ord<span style="color:#f92672">&gt;</span>(r: <span style="color:#a6e22e">RecursiveNTree</span><span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span>) -&gt; Option<span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    r.collapse_layers(<span style="color:#f92672">|</span>layer<span style="color:#f92672">|</span> layer.children.into_iter().filter_map(<span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> x).max())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Cool, right?</p>
<h1 id="async-io">Async IO</h1>
<p>I&rsquo;ve also used my crate to implement a small but fully functional filetree reader/file contents search tool example. It&rsquo;s fully async, with all the bells and whistles one might expect. <sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>. <a href="https://github.com/inanna-malick/recursion/blob/main/examples/grep.rs">You can find the source code here.</a>.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h1 id="to-be-continued">To be continued</h1>
<p>My next post will show how to implement different recursion backends (yes, this is where we finally get to see stack machines in action), along with some cool stuff with fused <code>expand_layers</code> and <code>collapse_layers</code> operations such that we can construct a recursive data structure and consume it at the same time, without having to allocate a <code>RecursiveTree</code>.</p>
<h1 id="thank-you">Thank you</h1>
<p>Thank you to <a href="https://twitter.com/munin">Fiona</a>, <a href="https://twitter.com/sunshowers6">Rain</a>, <a href="https://twitter.com/mycoliza">Eliza</a>, among others, for reviewing drafts of this post.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>If you&rsquo;re a recursion schemes nerd like me, you might notice that these correspond to catamorphism (a collapsing change) and anamorphism (an expanding change), but with less greek. They don&rsquo;t sound as cool, but I think they&rsquo;re a more readable representation of the same concept.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>In a perfect world, we could parameterize this over the <code>Layer</code> type (such as <code>ExprLayer</code>), but in Rust all types need to be fully applied, so we need to use <code>Wrapped</code> instead, to represent the fully applied <code>Layer&lt;A&gt;</code> type.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>If you&rsquo;re a functional programming nerd like me, you might recognize this as &lsquo;Functor&rsquo;&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p>a bolt of lightning strikes behind me. I am momentarily shown silhouetted by the actinic blue light. It is very dramatic&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p>ok, so it just uses <code>tokio::fs</code> (which just calls std lib blocking functions to work with the file system) instead of something hand crafted with manual file handle management, but there&rsquo;s a good reason I didn&rsquo;t implement that: I didn&rsquo;t want to&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

        
          <div class="blog-tags">
            
              
              <a href="https://recursion.wtf/tags/recursion-schemes/">recursion schemes</a>&nbsp;
            
              
              <a href="https://recursion.wtf/tags/rust/">rust</a>&nbsp;
            
              
              <a href="https://recursion.wtf/tags/code/">code</a>&nbsp;
            
              
              <a href="https://recursion.wtf/tags/generic/">generic</a>&nbsp;
            
          </div>
        

        
            <hr/>
            <section id="social-share">
              <div class="list-inline footer-links">
                

<div class="share-box" aria-hidden="true">
    <ul class="share">
      
      <li>
        <a href="//twitter.com/share?url=https%3a%2f%2frecursion.wtf%2fposts%2frust_schemes_2%2f&amp;text=Fully%20generic%20recursion%20in%20Rust&amp;via=" target="_blank" title="Share on Twitter">
          <i class="fab fa-twitter"></i>
        </a>
      </li>
  
      
      <li>
        <a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2frecursion.wtf%2fposts%2frust_schemes_2%2f" target="_blank" title="Share on Facebook">
          <i class="fab fa-facebook"></i>
        </a>
      </li>
  
      
      <li>
        <a href="//reddit.com/submit?url=https%3a%2f%2frecursion.wtf%2fposts%2frust_schemes_2%2f&amp;title=Fully%20generic%20recursion%20in%20Rust" target="_blank" title="Share on Reddit">
          <i class="fab fa-reddit"></i>
        </a>
      </li>
  
      
      <li>
        <a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2frecursion.wtf%2fposts%2frust_schemes_2%2f&amp;title=Fully%20generic%20recursion%20in%20Rust" target="_blank" title="Share on LinkedIn">
          <i class="fab fa-linkedin"></i>
        </a>
      </li>
  
      
      <li>
        <a href="//www.stumbleupon.com/submit?url=https%3a%2f%2frecursion.wtf%2fposts%2frust_schemes_2%2f&amp;title=Fully%20generic%20recursion%20in%20Rust" target="_blank" title="Share on StumbleUpon">
          <i class="fab fa-stumbleupon"></i>
        </a>
      </li>
  
      
      <li>
        <a href="//www.pinterest.com/pin/create/button/?url=https%3a%2f%2frecursion.wtf%2fposts%2frust_schemes_2%2f&amp;description=Fully%20generic%20recursion%20in%20Rust" target="_blank" title="Share on Pinterest">
          <i class="fab fa-pinterest"></i>
        </a>
      </li>
    </ul>
  </div>
  

              </div>
            </section>
        

        
          
            
          

          
                  <h4 class="see-also">See also</h4>
                  <ul>
                
                
                    <li><a href="/posts/detect/">Detect: a readable alternative to find/exec/grep</a></li>
                
                    <li><a href="/posts/recursion_lib_intro/">Recursion: a quick introduction</a></li>
                
                    <li><a href="/posts/rust_schemes_3/">Single Pass Recursion in Rust</a></li>
                
                    <li><a href="/posts/rust_schemes/">Elegant and performant recursion in Rust</a></li>
                
                    <li><a href="/posts/transitive-frontier/">Transitive Frontier</a></li>
                
              </ul>

          
        
      </article>

      
        <ul class="pager blog-pager">
          
            <li class="previous">
              <a href="https://recursion.wtf/posts/rust_schemes/" data-toggle="tooltip" data-placement="top" title="Elegant and performant recursion in Rust">&larr; Previous Post</a>
            </li>
          
          
            <li class="next">
              <a href="https://recursion.wtf/posts/rust_schemes_3/" data-toggle="tooltip" data-placement="top" title="Single Pass Recursion in Rust">Next Post &rarr;</a>
            </li>
          
        </ul>
      


      
      
      
      
      
        
      

    </div>
  </div>
</div>

      <footer>
  <div class="container">
    
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
          
          
          
        </ul>
        <p class="credits copyright text-muted">
          

          &nbsp;&bull;&nbsp;&copy;
          
            2025
          

          
            &nbsp;&bull;&nbsp;
            <a href="https://recursion.wtf/">Inanna Malick</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          <a href="https://gohugo.io">Hugo v0.147.8</a> powered &nbsp;&bull;&nbsp; Theme <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a> adapted from <a href="https://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a>
          
        </p>
      </div>
    </div>
  </div>
</footer><script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js" integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
<script src="https://code.jquery.com/jquery-3.7.0.slim.min.js" integrity="sha384-w5y/xIeYixWvfM+A1cEbmHPURnvyqmVg5eVENruEdDjcyRLUSNej7512JQGspFUr" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js" integrity="sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd" crossorigin="anonymous"></script>

<script src="https://recursion.wtf/js/main.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script><script src="https://recursion.wtf/js/load-photoswipe.js"></script>










    
  </body>
</html>

