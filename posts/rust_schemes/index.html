<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Elegant and performant recursion in Rust (Draft) :: [ recursion.wtf ]</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="This is a post about writing elegant and performant recursive algorithms in Rust. It makes heavy use of a pattern from Haskell called recursion schemes, but you don&amp;rsquo;t need to know anything about that. It&amp;rsquo;s just an implementation detail. Instead, as motivation to read the rest of this posts, check out these sick nasty criterion benchmark results showing a 20-30% improvement over the usual method of working with recursive data structures in Rust.
Evaluate expression tree of depth 17 with standard boxed method time: [722.18 µs 733.00 µs 746.43 µs] Evaluate expression tree of depth 17 with my new fold method time: [477.87 µs 482.54 µs 488.58 µs]  I think that&amp;rsquo;s neat.
" />
<meta name="keywords" content="recursion schemes, rust, code" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://recursion.wtf/posts/rust_schemes/" />




<link rel="stylesheet" href="https://recursion.wtf/assets/style.css">

  <link rel="stylesheet" href="https://recursion.wtf/assets/blue.css">






<link rel="apple-touch-icon" href="https://recursion.wtf/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="https://recursion.wtf/img/favicon/blue.png">



<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="inanna_malick" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Elegant and performant recursion in Rust (Draft)">
<meta property="og:description" content="This is a post about writing elegant and performant recursive algorithms in Rust. It makes heavy use of a pattern from Haskell called recursion schemes, but you don&amp;rsquo;t need to know anything about that. It&amp;rsquo;s just an implementation detail. Instead, as motivation to read the rest of this posts, check out these sick nasty criterion benchmark results showing a 20-30% improvement over the usual method of working with recursive data structures in Rust.
Evaluate expression tree of depth 17 with standard boxed method time: [722.18 µs 733.00 µs 746.43 µs] Evaluate expression tree of depth 17 with my new fold method time: [477.87 µs 482.54 µs 488.58 µs]  I think that&amp;rsquo;s neat.
" />
<meta property="og:url" content="https://recursion.wtf/posts/rust_schemes/" />
<meta property="og:site_name" content="[ recursion.wtf ]" />

  
    <meta property="og:image" content="https://recursion.wtf/img/favicon/blue.png">
  

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2002-07-12 00:00:00 &#43;0000 UTC" />












</head>
<body class="blue">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Inanna Malick
  </div>
</a>

    </div>
    
      <div class="menu-trigger">menu</div>
    
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="https://github.com/inanna-malick/">Github</a></li>
        
      
        
          <li><a href="https://twitter.com/inanna_malick">Twitter</a></li>
        
      
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="https://github.com/inanna-malick/">Github</a></li>
      
    
      
        <li><a href="https://twitter.com/inanna_malick">Twitter</a></li>
      
    
    
  </ul>
</nav>

  

  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Elegant and performant recursion in Rust (Draft)"/>
<meta name="twitter:description" content="This is a post about writing elegant and performant recursive algorithms in Rust. It makes heavy use of a pattern from Haskell called recursion schemes, but you don&rsquo;t need to know anything about that. It&rsquo;s just an implementation detail. Instead, as motivation to read the rest of this posts, check out these sick nasty criterion benchmark results showing a 20-30% improvement over the usual method of working with recursive data structures in Rust.
Evaluate expression tree of depth 17 with standard boxed method                                                                            
                        time:   [722.18 µs 733.00 µs 746.43 µs]

Evaluate expression tree of depth 17 with my new fold method                                                                            
                        time:   [477.87 µs 482.54 µs 488.58 µs]

I think that&rsquo;s neat."/>

  <meta property="og:title" content="Elegant and performant recursion in Rust (Draft)" />
<meta property="og:description" content="This is a post about writing elegant and performant recursive algorithms in Rust. It makes heavy use of a pattern from Haskell called recursion schemes, but you don&rsquo;t need to know anything about that. It&rsquo;s just an implementation detail. Instead, as motivation to read the rest of this posts, check out these sick nasty criterion benchmark results showing a 20-30% improvement over the usual method of working with recursive data structures in Rust.
Evaluate expression tree of depth 17 with standard boxed method                                                                            
                        time:   [722.18 µs 733.00 µs 746.43 µs]

Evaluate expression tree of depth 17 with my new fold method                                                                            
                        time:   [477.87 µs 482.54 µs 488.58 µs]

I think that&rsquo;s neat." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://recursion.wtf/posts/rust_schemes/" />
<meta property="article:published_time" content="2002-07-12T00:00:00+00:00" />
<meta property="article:modified_time" content="2002-07-12T00:00:00+00:00" /><meta property="og:site_name" content="[ recursion.wtf ]" />



</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://recursion.wtf/posts/rust_schemes/">Elegant and performant recursion in Rust (Draft)</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2002-07-12 
      </span>
    
    
    <span class="post-author">:: Inanna Malick</span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="https://recursion.wtf/tags/recursion-schemes/">recursion schemes</a>&nbsp;
    
    #<a href="https://recursion.wtf/tags/rust/">rust</a>&nbsp;
    
    #<a href="https://recursion.wtf/tags/code/">code</a>&nbsp;
    
  </span>
  

  
  

  

  <div class="post-content"><div>
        <p>This is a post about writing elegant and performant recursive algorithms in Rust. It makes heavy use of a pattern from Haskell called recursion schemes, but you don&rsquo;t need to know anything about that. It&rsquo;s just an implementation detail. Instead, as motivation to read the rest of this posts, check out these sick nasty criterion benchmark results showing a 20-30% improvement over the usual method of working with recursive data structures in Rust.</p>
<pre><font color="#A6CC70">Evaluate expression tree of depth 17 with standard boxed method</font>                                                                            
                        time:   [722.18 µs <font color="#77A8D9"><b>733.00 µs</b></font> 746.43 µs]

<font color="#A6CC70">Evaluate expression tree of depth 17 with my new fold method</font>                                                                            
                        time:   [477.87 µs <font color="#77A8D9"><b>482.54 µs</b></font> 488.58 µs]
</pre>
<p>I think that&rsquo;s neat.</p>
<h1 id="evaluating-an-expression-language">Evaluating an expression language<a href="#evaluating-an-expression-language" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>We&rsquo;re going to start with a simple expression language: addition, subtraction, multiplication, just enough to illustrate some concepts. This is a naive representation of a recursive expression language that uses boxed pointers to handle the recursive case. If you&rsquo;re not familiar to boxed pointers, a <code>Box&lt;A&gt;</code> is just the Rust way of storing a pointer to some value of type <code>A</code> - think of it as a box with a value of type <code>A</code> inside it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[derive(Debug, Clone)]</span>
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">ExprBoxed</span> {
    Add {
        a: Box<span style="color:#f92672">&lt;</span>ExprBoxed<span style="color:#f92672">&gt;</span>,
        b: Box<span style="color:#f92672">&lt;</span>ExprBoxed<span style="color:#f92672">&gt;</span>,
    },
    Sub {
        a: Box<span style="color:#f92672">&lt;</span>ExprBoxed<span style="color:#f92672">&gt;</span>,
        b: Box<span style="color:#f92672">&lt;</span>ExprBoxed<span style="color:#f92672">&gt;</span>,
    },
    Mul {
        a: Box<span style="color:#f92672">&lt;</span>ExprBoxed<span style="color:#f92672">&gt;</span>,
        b: Box<span style="color:#f92672">&lt;</span>ExprBoxed<span style="color:#f92672">&gt;</span>,
    },
    LiteralInt {
        literal: <span style="color:#66d9ef">i64</span>,
    },
}
</code></pre></div><p>You&rsquo;ve probably seen something like this before, but if not, it&rsquo;s just a way to represent simple arithmetic. For example, an expression like <code>1 * 2 - 3</code> would be written as (pseudocode) <code>Mul(1, Sub(2, 3))</code> or (actual code) this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">    ExprBoxed::Mul {
        a: Box::new(ExprBoxed::LiteralInt { literal: <span style="color:#ae81ff">1</span> }),
        b: Box::new(ExprBoxed::Sub {
            a: Box::new(ExprBoxed::LiteralInt { literal: <span style="color:#ae81ff">2</span> }),
            b: Box::new(ExprBoxed::LiteralInt { literal: <span style="color:#ae81ff">3</span> }),
        }),
    }
</code></pre></div><p>Evaluating expressions is pretty simple - it&rsquo;s just addition, subtraction, and multiplication. This recursive eval function provides a fairly elegant and readable example of a recursive algorithm:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span> ExprBoxed {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">eval</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">i64</span> {
        <span style="color:#66d9ef">match</span> <span style="color:#f92672">&amp;</span>self {
            ExprBoxed::Add { a, b } <span style="color:#f92672">=&gt;</span> a.eval() <span style="color:#f92672">+</span> b.eval(),
            ExprBoxed::Sub { a, b } <span style="color:#f92672">=&gt;</span> a.eval() <span style="color:#f92672">-</span> b.eval(),
            ExprBoxed::Mul { a, b } <span style="color:#f92672">=&gt;</span> a.eval() <span style="color:#f92672">*</span> b.eval(),
            ExprBoxed::LiteralInt { literal } <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">*</span>literal,
        }
    }
}
</code></pre></div><p>It has some issues: if we try to evaluate a sufficiently large expression it will fail with a stack overflow - we&rsquo;re not likely to hit that case here, but this is a real problem when working with larger recursive data structures. Also, each recursive <code>eval</code> call requires us to traverse a boxed pointer. This means we can&rsquo;t take advantage of cache locality - there&rsquo;s no guarantee that all these boxed pointers live in the same region of memory.</p>
<h2 id="optimizing-for-performance">Optimizing for performance<a href="#optimizing-for-performance" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>We can fix that by writing an expression language using a Vec of values (guaranteeing memory locality), with boxed pointers replaced with usize indices pointing into our vector.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Expr</span><span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span> {
    Add { a: <span style="color:#a6e22e">A</span>, b: <span style="color:#a6e22e">A</span> },
    Sub { a: <span style="color:#a6e22e">A</span>, b: <span style="color:#a6e22e">A</span> },
    Mul { a: <span style="color:#a6e22e">A</span>, b: <span style="color:#a6e22e">A</span> },
    LiteralInt { literal: <span style="color:#66d9ef">i64</span> },
}
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">RecursiveExpr</span> {
    <span style="color:#e6db74">/// nonempty, in topological-sorted order. for every node `n`, all of `n`&#39;s child nodes have vec indices greater than that of n
</span><span style="color:#e6db74"></span>    elems: Vec<span style="color:#f92672">&lt;</span>Expr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;&gt;</span>,
}
</code></pre></div><p>We&rsquo;re also going to define a function to map from one type of Expr to another, for convenience - nothing complex, it just applies a function to each &lsquo;A&rsquo;, sort of like mapping over an Option or an Iterator. If you&rsquo;re familiar with functional languages, this is basically just <code>fmap</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span> Expr<span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">map</span><span style="color:#f92672">&lt;</span>B, F: FnMut(A) -&gt; <span style="color:#a6e22e">B</span><span style="color:#f92672">&gt;</span>(self, <span style="color:#66d9ef">mut</span> f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Expr</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> {
        <span style="color:#66d9ef">match</span> self {
            Expr::Add { a, b } <span style="color:#f92672">=&gt;</span> Expr::Add { a: <span style="color:#a6e22e">f</span>(a), b: <span style="color:#a6e22e">f</span>(b) },
            Expr::Sub { a, b } <span style="color:#f92672">=&gt;</span> Expr::Sub { a: <span style="color:#a6e22e">f</span>(a), b: <span style="color:#a6e22e">f</span>(b) },
            Expr::Mul { a, b } <span style="color:#f92672">=&gt;</span> Expr::Mul { a: <span style="color:#a6e22e">f</span>(a), b: <span style="color:#a6e22e">f</span>(b) },
            Expr::LiteralInt { literal } <span style="color:#f92672">=&gt;</span> Expr::LiteralInt { literal },
        }
    }
}
</code></pre></div><p>The problem here is that this is harder to read - we don&rsquo;t want to construct these by hand, because it would be tedious and error prone. Instead, we&rsquo;ll just create them from boxed expressions. Here&rsquo;s how: start with a boxed expression, unfold a single layer of structure from it, then just repeatedly unfold layers until there aren&rsquo;t any more layers to unfold. Feel free to skim this function, it&rsquo;s  only here is to demonstrate what non-elegant recursive code looks like.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span> RecursiveExpr {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">from_boxed</span>(a: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">ExprBoxed</span>) -&gt; <span style="color:#a6e22e">Self</span> {
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> frontier: <span style="color:#a6e22e">VecDeque</span><span style="color:#f92672">&lt;&amp;</span>ExprBoxed<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> VecDeque::from([a]);
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> elems <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[];

        <span style="color:#75715e">// unfold to build a vec of elems while preserving topo order
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(seed) <span style="color:#f92672">=</span> frontier.pop_front() {
            <span style="color:#66d9ef">let</span> node <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> seed {
                ExprBoxed::Add { a, b } <span style="color:#f92672">=&gt;</span> Expr::Add { a, b },
                ExprBoxed::Sub { a, b } <span style="color:#f92672">=&gt;</span> Expr::Sub { a, b },
                ExprBoxed::Mul { a, b } <span style="color:#f92672">=&gt;</span> Expr::Mul { a, b },
                ExprBoxed::LiteralInt { literal } <span style="color:#f92672">=&gt;</span> Expr::LiteralInt { literal: <span style="color:#f92672">*</span>literal },
            };

            <span style="color:#66d9ef">let</span> node <span style="color:#f92672">=</span> node.map(<span style="color:#f92672">|</span>aa<span style="color:#f92672">|</span> {
                frontier.push_back(aa);
                <span style="color:#75715e">// idx of pointed-to element determined from frontier + elems size
</span><span style="color:#75715e"></span>                elems.len() <span style="color:#f92672">+</span> frontier.len()
            });

            elems.push(node);
        }

        Self { elems }
    }
}
</code></pre></div><p>It&rsquo;s not exactly elegant, right? The <code>let node = match {...}</code> block defines a single recursive step, which builds a single layer of <code>Expr&lt;&amp;ExprBoxed&gt;</code> structure from an <code>&amp;ExprBoxed</code> seed value, but it&rsquo;s surrounded with a bunch of bookkeeping boilerplate that handles combining the layers to build a vec of <code>Expr&lt;usize&gt;</code>.</p>
<p>Don&rsquo;t worry, we have a fix for this. Before we can get to that, let&rsquo;s look at what evaluating a a <code>RecursiveExpr</code> looks like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span> RecursiveExpr {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">eval</span>(self) -&gt; <span style="color:#66d9ef">i64</span> {
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> results: <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span>, <span style="color:#66d9ef">i64</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> HashMap::with_capacity(self.elems.len());

        <span style="color:#66d9ef">for</span> (idx, node) <span style="color:#66d9ef">in</span> self.elems.into_iter().enumerate().rev() {
            <span style="color:#75715e">// each node is only referenced once so just remove it
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">let</span> node <span style="color:#f92672">=</span> node.map(<span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> results.remove(<span style="color:#f92672">&amp;</span>x).expect(<span style="color:#e6db74">&#34;node not in result map&#34;</span>));
            <span style="color:#66d9ef">let</span> alg_res <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> node {
                Expr::Add { a, b } <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">+</span> b,
                Expr::Sub { a, b } <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">-</span> b,
                Expr::Mul { a, b } <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">*</span> b,
                Expr::LiteralInt { literal } <span style="color:#f92672">=&gt;</span> literal,
            };
            results.insert(idx, alg_res);
        }

        results.remove(<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0</span>).unwrap()
    }
}
</code></pre></div><p>Here we fold up the expression tree from the leaves to the root, evaluating it one layer at a time and storing the results in a hash map until they are used. Since everything we&rsquo;re folding over is stored in a vec, in one contiguous region of memory, we don&rsquo;t need to worry about the overhead of traversing a bunch of pointers (I have benchmarks over a more optimized version that shows a consistient 20-30% improvement over evaluating boxed <code>ExprBoxed</code> nodes).</p>
<p>Unfortunately, it&rsquo;s not elegant. Once again, the logic of <em>how</em> we fold layers of recursive structure (<code>Expr&lt;i64&gt;</code>) into a single value (<code>i64</code>) is combined with a bunch of boilerplate that handles the actual mechanics of recursion.</p>
<p>Let&rsquo;s fix that.</p>
<h1 id="recursion-schemes">RECURSION SCHEMES<a href="#recursion-schemes" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>The key idea here, which is taken entirely from recursion schemes, is to <em>separate</em> the mechanism of recursion from the logic of recursion. Let&rsquo;s see what that looks like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span> RecursiveExpr {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fold</span><span style="color:#f92672">&lt;</span>A, F: FnMut(Expr<span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">A</span><span style="color:#f92672">&gt;</span>(self, <span style="color:#66d9ef">mut</span> fold_layer: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">A</span> {
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> results: <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span>, A<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> HashMap::with_capacity(self.elems.len());

        <span style="color:#66d9ef">for</span> (idx, node) <span style="color:#66d9ef">in</span> self.elems.into_iter().enumerate().rev() {
            <span style="color:#75715e">// each node is only referenced once so just remove it
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">let</span> node <span style="color:#f92672">=</span> node.map(<span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> results.remove(<span style="color:#f92672">&amp;</span>x).expect(<span style="color:#e6db74">&#34;node not in result map&#34;</span>));
            <span style="color:#66d9ef">let</span> alg_res <span style="color:#f92672">=</span> fold_layer(node);
            results.insert(idx, alg_res);
        }

        results.remove(<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0</span>).unwrap()
    }
}
</code></pre></div><p>First, we have a generic representation of folding some structure into a single value - instead of folding an <code>Expr&lt;i64&gt;</code> into a single <code>i64</code>, we fold some <code>Expr&lt;A&gt;</code> into an <code>A</code>. The code looks pretty much the same as <code>eval</code>, but it lets us factor out the mechanism of recursion.</p>
<p>Here&rsquo;s what <code>eval</code> looks like using this idiom:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span> RecursiveExpr {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">eval</span>(self) -&gt; <span style="color:#66d9ef">i64</span> {
        self.fold(<span style="color:#f92672">|</span>expr<span style="color:#f92672">|</span> <span style="color:#66d9ef">match</span> expr {
            Expr::Add { a, b } <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">+</span> b,
            Expr::Sub { a, b } <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">-</span> b,
            Expr::Mul { a, b } <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">*</span> b,
            Expr::LiteralInt { literal } <span style="color:#f92672">=&gt;</span> literal,
        })
    }
}
</code></pre></div><p>It&rsquo;s pretty much the same logic as the previous <code>eval</code> functions, without any of the boilerplate. Since there&rsquo;s less boilerplate, it&rsquo;s easier to review and there&rsquo;s less room for bugs. In fact, it actually contains slightly less boilerplate than the eval function we wrote for <code>ExprBoxed::eval</code> because it doesn&rsquo;t have to handle recursively calling itself. Also, it retains all the performance benefits of the previous <code>eval</code> implementation - it&rsquo;s both more elegant and more performant than the traditional representation of recursive expression trees in rust. I think that&rsquo;s neat.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span> RecursiveExpr {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">unfold</span><span style="color:#f92672">&lt;</span>A, F: Fn(A) -&gt; <span style="color:#a6e22e">Expr</span><span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;&gt;</span>(a: <span style="color:#a6e22e">A</span>, unfold_layer: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Self</span> {
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> frontier <span style="color:#f92672">=</span> VecDeque::from([a]);
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> elems <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[];

        <span style="color:#75715e">// unfold to build a vec of elems while preserving topo order
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(seed) <span style="color:#f92672">=</span> frontier.pop_front() {
            <span style="color:#66d9ef">let</span> node <span style="color:#f92672">=</span> unfold_layer(seed);

            <span style="color:#66d9ef">let</span> node <span style="color:#f92672">=</span> node.map(<span style="color:#f92672">|</span>aa<span style="color:#f92672">|</span> {
                frontier.push_back(aa);
                <span style="color:#75715e">// idx of pointed-to element determined from frontier + elems size
</span><span style="color:#75715e"></span>                elems.len() <span style="color:#f92672">+</span> frontier.len()
            });

            elems.push(node);
        }

        Self { elems }
    }
}
</code></pre></div><p>Here we have a generic representation of unfolding some structure from a single value - instead of unfolding a single layer of <code>Expr&lt;&amp;ExprBoxed&gt;</code> structure from an <code>&amp;ExprBoxed</code> seed value, we unfold some <code>A</code> into an <code>Expr&lt;A&gt;</code>. As with <code>fold</code>, the code looks pretty much the same as <code>from_boxed</code>, just with the specific unfold logic factored out.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span> RecursiveExpr {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">from_boxed</span>(e: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">ExprBoxed</span>) -&gt; <span style="color:#a6e22e">Self</span> {
        Self::unfold(e, <span style="color:#f92672">|</span>seed<span style="color:#f92672">|</span> <span style="color:#66d9ef">match</span> seed {
            ExprBoxed::Add { a, b } <span style="color:#f92672">=&gt;</span> Expr::Add { a, b },
            ExprBoxed::Sub { a, b } <span style="color:#f92672">=&gt;</span> Expr::Sub { a, b },
            ExprBoxed::Mul { a, b } <span style="color:#f92672">=&gt;</span> Expr::Mul { a, b },
            ExprBoxed::LiteralInt { literal } <span style="color:#f92672">=&gt;</span> Expr::LiteralInt { literal: <span style="color:#f92672">*</span>literal },
        })
    }
}
</code></pre></div><p>Here&rsquo;s what <code>RecursiveExpr::from_boxed</code> looks like as written using <code>unfold</code>. Just as before, there&rsquo;s almost no boilerplate, the body of the function is almost entirely taken up by the logic of unfolding.</p>
<h1 id="testing-for-correctness">Testing for Correctness<a href="#testing-for-correctness" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>I used proptest to test this code for correctness. It generates many expression trees, each of which is evaluated via both <code>eval</code> methods. I then assert that they have the same result. (todo: describe this technique in more detail, credit Rain)</p>
<p>This actually helped me find a bug! In my first implementation of <code>unfold</code>, I used a stack instead of a queue for the frontier, which ended up mangling the order of the expression tree. Since proptest is awesome, it not only found this bug but reduced the failing test case to <code>Add (0, Sub(0, 1))</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// generate a bunch of expression trees and evaluate them via each method
</span><span style="color:#75715e"></span><span style="color:#75715e">#[cfg(test)]</span>
proptest<span style="color:#f92672">!</span> {
    <span style="color:#75715e">#[test]</span>
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">expr_eval</span>(boxed_expr <span style="color:#66d9ef">in</span> arb_expr()) {
        <span style="color:#66d9ef">let</span> eval_boxed <span style="color:#f92672">=</span> boxed_expr.eval();
        <span style="color:#66d9ef">let</span> eval_via_fold <span style="color:#f92672">=</span> RecursiveExpr::from_boxed(<span style="color:#f92672">&amp;</span>boxed_expr).eval();

        assert_eq<span style="color:#f92672">!</span>(eval_boxed, eval_via_fold);
    }
}

<span style="color:#75715e">#[cfg(test)]</span>
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">arb_expr</span>() -&gt; <span style="color:#a6e22e">impl</span> Strategy<span style="color:#f92672">&lt;</span>Value <span style="color:#f92672">=</span> ExprBoxed<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> leaf <span style="color:#f92672">=</span> any::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i8</span><span style="color:#f92672">&gt;</span>().prop_map(<span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> ExprBoxed::LiteralInt { literal: <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i64</span> });
    leaf.prop_recursive(
        <span style="color:#ae81ff">8</span>,   <span style="color:#75715e">// 8 levels deep
</span><span style="color:#75715e"></span>        <span style="color:#ae81ff">256</span>, <span style="color:#75715e">// Shoot for maximum size of 256 nodes
</span><span style="color:#75715e"></span>        <span style="color:#ae81ff">10</span>,  <span style="color:#75715e">// We put up to 10 items per collection
</span><span style="color:#75715e"></span>        <span style="color:#f92672">|</span>inner<span style="color:#f92672">|</span> {
            prop_oneof<span style="color:#f92672">!</span>[
                (inner.clone(), inner.clone()).prop_map(<span style="color:#f92672">|</span>(a, b)<span style="color:#f92672">|</span> ExprBoxed::Add {
                    a: Box::new(a),
                    b: Box::new(b)
                }),
                (inner.clone(), inner.clone()).prop_map(<span style="color:#f92672">|</span>(a, b)<span style="color:#f92672">|</span> ExprBoxed::Sub {
                    a: Box::new(a),
                    b: Box::new(b)
                }),
                (inner.clone(), inner).prop_map(<span style="color:#f92672">|</span>(a, b)<span style="color:#f92672">|</span> ExprBoxed::Mul {
                    a: Box::new(a),
                    b: Box::new(b)
                }),
            ]
        },
    )
}
</code></pre></div><h1 id="testing-for-performance">Testing for performance<a href="#testing-for-performance" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>For performance testing, we used criterion to benchmark the simple <code>ExprBoxed::eval</code> vs our <code>RecursiveExpr::eval</code>. This code basically just builds up a really big (as in, 131072 nodes) recursive structure (using unfold/fold, because they&rsquo;re honestly really convenient) and evaluates it a bunch of times.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">bench_eval</span>(criterion: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Criterion) {
    <span style="color:#66d9ef">let</span> big_expr <span style="color:#f92672">=</span> RecursiveExpr::unfold(<span style="color:#ae81ff">17</span>, <span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> {
        <span style="color:#66d9ef">if</span> x <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> {
            Expr::Add(x <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, x <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
        } <span style="color:#66d9ef">else</span> {
            Expr::LiteralInt(<span style="color:#ae81ff">0</span>)
        }
    });

    <span style="color:#66d9ef">let</span> boxed_big_expr <span style="color:#f92672">=</span> big_expr.as_ref().fold(<span style="color:#f92672">|</span>n<span style="color:#f92672">|</span> <span style="color:#66d9ef">match</span> n {
        Expr::Add(a, b) <span style="color:#f92672">=&gt;</span> Box::new(ExprBoxed::Add(a, b)),
        Expr::LiteralInt(x) <span style="color:#f92672">=&gt;</span> Box::new(ExprBoxed::LiteralInt(x)),
        _ <span style="color:#f92672">=&gt;</span> unreachable<span style="color:#f92672">!</span>(),
    });

    <span style="color:#66d9ef">let</span> h <span style="color:#f92672">=</span> HashMap::new();

    criterion.bench_function(<span style="color:#e6db74">&#34;eval boxed&#34;</span>, <span style="color:#f92672">|</span>b<span style="color:#f92672">|</span> {
        b.iter(<span style="color:#f92672">||</span> naive_eval(<span style="color:#f92672">&amp;</span>h, black_box(<span style="color:#f92672">&amp;</span>boxed_big_expr)))
    });
    criterion.bench_function(<span style="color:#e6db74">&#34;eval fold&#34;</span>, <span style="color:#f92672">|</span>b<span style="color:#f92672">|</span> b.iter(<span style="color:#f92672">||</span> eval(<span style="color:#f92672">&amp;</span>h, black_box(<span style="color:#f92672">&amp;</span>big_expr))));
}

criterion_group<span style="color:#f92672">!</span>(benches, bench_eval);
criterion_main<span style="color:#f92672">!</span>(benches);
</code></pre></div><p>Here&rsquo;s the result, after a few optimization passes:</p>
<pre><font color="#A6CC70">Evaluate expression tree of depth 17 with standard boxed method</font>                                                                            
                        time:   [722.18 µs <font color="#77A8D9"><b>733.00 µs</b></font> 746.43 µs]

<font color="#A6CC70">Evaluate expression tree of depth 17 with my new fold method</font>                                                                            
                        time:   [477.87 µs <font color="#77A8D9"><b>482.54 µs</b></font> 488.58 µs]
</pre>
<p>Evaluating a boxed expression of size  takes an average 785.41 µs. Evaluating an expression stored in our <code>RecursiveExpr</code> takes an average of 559.22 µs. That&rsquo;s a 28% improvement. Running these tests with expression trees of different depths generated via the above method yields similar results.</p>
<h1 id="to-be-continued">To be continued<a href="#to-be-continued" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>We started with a simplified non-generic version of this algorithm to build understanding. In future blog posts, I plan on showing how I made it generic, how I optimized it for performance (<code>MaybeUninit</code> absolutely slaps), and how I used it to implement an async file tree search tool using <code>tokio::fs</code>.</p>
      </div></div>

  
  
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        <span class="button previous">
            <a href="https://recursion.wtf/posts/transitive-frontier/">
                <span class="button__icon">←</span>
                <span class="button__text">Transitive Frontier</span>
            </a>
        </span>
        
        
    </div>
</div>

  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2022 Powered by <a href="http://gohugo.io">Hugo</a></span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="https://recursion.wtf/assets/main.js"></script>
<script src="https://recursion.wtf/assets/prism.js"></script>







  
</div>

</body>
</html>
