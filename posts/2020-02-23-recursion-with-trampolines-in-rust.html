<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Recursion dot WTF - Recursion with trampolines in Rust</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">RECURSION DOT WTF</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Recursion with trampolines in Rust</h1>
            <article>
    <section class="header">
        Posted on February 23, 2020
        
    </section>
    <section>
        <p>I’ve spent a lot of time writing recursive functions over the last few years, first in Scala and then in Haskell.</p>
<p>I just like recursive functions - they’re concise, elegant, and I’ve been using them for long enough that they’re one of the first tools I reach for when designing an algorithm.</p>
<p>One of the main hurdles I’ve had to overcome while learning Rust is the realization that, most of the time, recursive functions just aren’t idiomatic. In Rust, each recursive function call adds another frame to the stack, resulting in stack overflows depending on the number of times the function calls itself. Haskell doesn’t have this problem (it uses a graph evaluation model), and Scala provides tools for writing tail-recursive functions that can recurse without adding framesto the stack, but Rust really just doesn’t want you to write recursive functions. In practice, this hasn’t been a problem. Rust provides recursive-seeming combinators like <code>fold</code> that compile down to non-recursive for loops, and is generally a very pleasant language to work in. Occassionally, I find myself thinking through a problem, finding a simple recursive solution, and then implementing it in a stack-safe way using for loops and a <code>Vec</code> as a stack.</p>
<p>So far, I’ve only found one problem for which the best solution is a recursive algorithm, uploading a tree of nodes to a hash-addressed store like IPFS. This blog post will describe that problem and the recursive async solution I found for it.</p>
<h1 id="uploading-nodes-to-ipfs">Uploading nodes to IPFS</h1>
<p>IPFS provides a distributed store for DAG (directed acyclic graph) nodes. These nodes consist of a body and some set of links to other nodes. Basically, you send it a node, it hashes that node, stores it, and returns the hash. Here’s a simplified sketch showing what that looks like:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">type</span> Hash = <span class="dt">Vec</span>&lt;<span class="dt">u8</span>&gt;;</a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">struct</span> IPFSNode <span class="op">{</span></a>
<a class="sourceLine" id="cb1-4" title="4">  body: <span class="dt">String</span>,</a>
<a class="sourceLine" id="cb1-5" title="5">  links: <span class="dt">Vec</span>&lt;<span class="bu">Hash</span>&gt;,</a>
<a class="sourceLine" id="cb1-6" title="6"><span class="op">}</span></a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8">async <span class="kw">fn</span> upload_node(node: IPFSNode) -&gt; <span class="bu">Hash</span> <span class="op">{</span>...<span class="op">}</span></a></code></pre></div>
<p>(Sidebar: The IPFS hash function isn’t well documented, so the only way to get the canonical hash for an IPFSNode is to upload it to an IPFS daemon - we can’t generate node hashes locally)</p>
<p>It’d be pretty easy to expose this as an HTTP API - just take a JSON-encoded IPFS node, upload it to IPFS, and return the hash. The IPFS daemon does just that. However, that API would require one HTTP round trip per node uploaded, and sometimes users might want to upload several nodes in one API request. Further, they might want to upload a <em>tree</em> of newly created nodes. Let’s sketch this out.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">struct</span> NodeTree <span class="op">{</span></a>
<a class="sourceLine" id="cb2-2" title="2">  body: <span class="dt">String</span>,</a>
<a class="sourceLine" id="cb2-3" title="3">  children: <span class="dt">Vec</span>&lt;NodeTree&gt;,</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="op">}</span></a></code></pre></div>
<p>(Sidebar: for reasons of memory locality it might make more sense to implement this as a <code>HashMap</code> backed structure instead of a recursive data structure)</p>
<p>What we want to do is to write a function <code>async fn upload_nodes(node_tree: NodeTree) -&gt; Hash</code> that uploads the entire recursive <code>NodeTree</code> structure, starting with the leaf nodes. Here’s a sketch showing what we want to happen:</p>
<pre><code>          |
       +--------+
       | Node 1 |
       +--------+
          |
      +-----------+
      |           |
 +--------+  +--------+
 | Node 2 |  | Node 3 |
 +--------+  +--------+
      |
      +-----------+
      |           |
 +--------+  +--------+
 | Node 4 |  | Node 5 |
 +--------+  +--------+</code></pre>
<p>First, we start with a node tree a few levels deep. Nodes 3, 4 and 5 are leaf nodes, so we can upload them to IPFS, as <code>IPFSNode{ body: &quot;Node 3&quot;, links: Vec::new() }</code>, <code>IPFSNode{ body: &quot;Node 4&quot;, links: Vec::new() }</code>, and so on, getting a hash for each node uploaded to IPFS.</p>
<pre><code>          |
       +--------+
       | Node 1 |
       +--------+
          |
      +-----------+
      |           |
 +--------+       v
 | Node 2 |   node_3_hash
 +--------+
      |
      +-----------+
      |           |
      v           v
 node_4_hash   node_5_hash</code></pre>
<p>Having done so, we can now upload Node 2 as <code>IPFSNode { body: &quot;Node 2&quot;, links: vec![node_4_hash, node_5_hash]}</code>.</p>
<pre><code>
          |
       +--------+
       | Node 1 |
       +--------+
          |
      +-----------+
      |           |
      v           v
 node_2_hash   node_3_hash</code></pre>
<p>Now that we have a hash for every child node of Node 1, we can upload it as <code>IPFSNode { body: &quot;Node 2&quot;, links: vec![node_2_hash, node_3_hash]}</code>.</p>
<pre><code>
          |
          v
      node_1_hash 
</code></pre>
<p>Finally, we have a hash for the root node.</p>
<p>Let’s take a crack at implementing <code>upload_nodes</code>. We want everything to work even if the tree we upload is a few thousand nodes deep, so we can’t recurse.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">use</span> <span class="pp">tokio::sync::</span>oneshot;</a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3">async <span class="kw">fn</span> upload_nodes(node_tree: NodeTree) -&gt; <span class="bu">Hash</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-4" title="4">  <span class="kw">let</span> children = <span class="pp">futures::future::</span>join_all(node_tree.children.into_iter().map(upload_nodes_worker)).await;</a>
<a class="sourceLine" id="cb7-5" title="5">  </a>
<a class="sourceLine" id="cb7-6" title="6">  <span class="kw">let</span> ipfs_node = IPFSNode <span class="op">{</span></a>
<a class="sourceLine" id="cb7-7" title="7">    children, </a>
<a class="sourceLine" id="cb7-8" title="8">    body: node_tree.body,</a>
<a class="sourceLine" id="cb7-9" title="9">  <span class="op">}</span></a>
<a class="sourceLine" id="cb7-10" title="10">  </a>
<a class="sourceLine" id="cb7-11" title="11">  </a>
<a class="sourceLine" id="cb7-12" title="12"><span class="op">}</span></a>
<a class="sourceLine" id="cb7-13" title="13"></a>
<a class="sourceLine" id="cb7-14" title="14"><span class="kw">fn</span> upload_nodes_worker(node_tree: NodeTree) -&gt; <span class="pp">tokio::</span>JoinHandle&lt;<span class="bu">Hash</span>&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb7-15" title="15">  <span class="pp">tokio::</span>spawn(upload_nodes(node_tree))</a>
<a class="sourceLine" id="cb7-16" title="16"><span class="op">}</span></a></code></pre></div>
    </section>
</article>

        </main>
    </body>
</html>
