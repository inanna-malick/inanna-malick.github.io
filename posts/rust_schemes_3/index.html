<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Single Pass Recursion in Rust :: [ recursion.wtf ]</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="This is the third post in a three-post series. In the first post we developed a stack-safe, ergonomic, and concise method for working with recursive data structures (using a simple expression language as an example). In the second post we made it fully generic, providing a set of generic tools for expanding and collapsing any recursive data structure in Rust.
In this post we will see how to combine these two things - expanding a structure and collapsing it at the same time, performing both operations in a single pass. In the process, we will gain the ability to write arbitrary recursive functions over traditional boxed-pointer recursive structures (instead of the novel RecursiveTree type introduced in my previous post) while retaining stack safety.
" />
<meta name="keywords" content="recursion schemes, rust, code, stack_machines" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://recursion.wtf/posts/rust_schemes_3/" />




<link rel="stylesheet" href="https://recursion.wtf/assets/style.css">

  <link rel="stylesheet" href="https://recursion.wtf/assets/blue.css">






<link rel="apple-touch-icon" href="https://recursion.wtf/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="https://recursion.wtf/img/favicon/blue.png">



<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="inanna_malick" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Single Pass Recursion in Rust">
<meta property="og:description" content="This is the third post in a three-post series. In the first post we developed a stack-safe, ergonomic, and concise method for working with recursive data structures (using a simple expression language as an example). In the second post we made it fully generic, providing a set of generic tools for expanding and collapsing any recursive data structure in Rust.
In this post we will see how to combine these two things - expanding a structure and collapsing it at the same time, performing both operations in a single pass. In the process, we will gain the ability to write arbitrary recursive functions over traditional boxed-pointer recursive structures (instead of the novel RecursiveTree type introduced in my previous post) while retaining stack safety.
" />
<meta property="og:url" content="https://recursion.wtf/posts/rust_schemes_3/" />
<meta property="og:site_name" content="[ recursion.wtf ]" />

  <meta property="og:image" content="https://recursion.wtf/img/rust_schemes/stack_machines_1/simple_expr_eval.gif">

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2022-10-05 00:00:00 &#43;0000 UTC" />












</head>
<body class="blue">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Inanna Malick
  </div>
</a>

    </div>
    
      <div class="menu-trigger">menu</div>
    
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="https://github.com/inanna-malick/">Github</a></li>
        
      
        
          <li><a href="https://hachyderm.io/@Inanna">Mastodon</a></li>
        
      
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="https://github.com/inanna-malick/">Github</a></li>
      
    
      
        <li><a href="https://hachyderm.io/@Inanna">Mastodon</a></li>
      
    
    
  </ul>
</nav>

  

  <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://recursion.wtf/img/rust_schemes/stack_machines_1/simple_expr_eval.gif"/>

<meta name="twitter:title" content="Single Pass Recursion in Rust"/>
<meta name="twitter:description" content="This is the third post in a three-post series. In the first post we developed a stack-safe, ergonomic, and concise method for working with recursive data structures (using a simple expression language as an example). In the second post we made it fully generic, providing a set of generic tools for expanding and collapsing any recursive data structure in Rust.
In this post we will see how to combine these two things - expanding a structure and collapsing it at the same time, performing both operations in a single pass. In the process, we will gain the ability to write arbitrary recursive functions over traditional boxed-pointer recursive structures (instead of the novel RecursiveTree type introduced in my previous post) while retaining stack safety.

  "/>

  <meta property="og:title" content="Single Pass Recursion in Rust" />
<meta property="og:description" content="This is the third post in a three-post series. In the first post we developed a stack-safe, ergonomic, and concise method for working with recursive data structures (using a simple expression language as an example). In the second post we made it fully generic, providing a set of generic tools for expanding and collapsing any recursive data structure in Rust.
In this post we will see how to combine these two things - expanding a structure and collapsing it at the same time, performing both operations in a single pass. In the process, we will gain the ability to write arbitrary recursive functions over traditional boxed-pointer recursive structures (instead of the novel RecursiveTree type introduced in my previous post) while retaining stack safety.

  " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://recursion.wtf/posts/rust_schemes_3/" />
<meta property="og:image" content="https://recursion.wtf/img/rust_schemes/stack_machines_1/simple_expr_eval.gif" />
<meta property="article:published_time" content="2022-10-05T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-10-05T00:00:00+00:00" /><meta property="og:site_name" content="[ recursion.wtf ]" />



</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://recursion.wtf/posts/rust_schemes_3/">Single Pass Recursion in Rust</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2022-10-05 
      </span>
    
    
    <span class="post-author">:: Inanna Malick</span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="https://recursion.wtf/tags/recursion-schemes/">recursion schemes</a>&nbsp;
    
    #<a href="https://recursion.wtf/tags/rust/">rust</a>&nbsp;
    
    #<a href="https://recursion.wtf/tags/code/">code</a>&nbsp;
    
    #<a href="https://recursion.wtf/tags/generic/">generic</a>&nbsp;
    
    #<a href="https://recursion.wtf/tags/stack_machines/">stack_machines</a>&nbsp;
    
  </span>
  

  
  

  

  <div class="post-content"><div>
        <p>This is the third post in a three-post series. In the <a href="https://recursion.wtf/posts/rust_schemes">first post</a> we developed a stack-safe, ergonomic, and concise method for working with recursive data structures (using a simple expression language as an example). In the <a href="https://recursion.wtf/posts/rust_schemes_2">second post</a> we made it fully generic, providing a set of generic tools for expanding and collapsing <em>any</em> recursive data structure in Rust.</p>
<p>In this post we will see how to <em>combine</em> these two things - expanding a structure and collapsing it at the same time, performing both operations in a single pass. In the process, we will gain the ability to write arbitrary recursive functions over traditional boxed-pointer recursive structures (instead of the novel <code>RecursiveTree</code> type introduced in my previous post) while retaining stack safety.</p>

  <img src="/img/rust_schemes/stack_machines_1/simple_expr_eval.gif"  alt="execution graph for simultaneously expanding and collapsing a simple expression"  class="center"  style="border-radius: 8px;"  />


<p>This post covers functionality already implemented in my <a href="https://crates.io/crates/recursion">recursion</a> crate. For that reason, it will focus on diagrams over code, but the relevant code is provided if you're interested or curious.</p>
<h2 id="our-expression-language">Our Expression Language<a href="#our-expression-language" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Earlier in this series we defined a simple expression language for math, using this enum to represent <em>a single layer</em> of an expression tree:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">ExprLayer</span><span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span> {
    Add { a: <span style="color:#a6e22e">A</span>, b: <span style="color:#a6e22e">A</span> },
    Sub { a: <span style="color:#a6e22e">A</span>, b: <span style="color:#a6e22e">A</span> },
    Mul { a: <span style="color:#a6e22e">A</span>, b: <span style="color:#a6e22e">A</span> },
    LiteralInt { literal: <span style="color:#66d9ef">i64</span> },
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ExprBoxed</span>(Box<span style="color:#f92672">&lt;</span>ExprLayer<span style="color:#f92672">&lt;</span>ExprBoxed<span style="color:#f92672">&gt;&gt;</span>);
</code></pre></div><p>So that we can easily write expressions out by hand (for test cases and examples), let's define some helper functions (specifics omitted).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// some simple utility functions for creating boxed expressions
</span><span style="color:#75715e"></span><span style="color:#66d9ef">impl</span> ExprBoxed {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">add</span>(a: <span style="color:#a6e22e">Self</span>, b: <span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Self</span> { ... }
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sub</span>(a: <span style="color:#a6e22e">Self</span>, b: <span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Self</span> { ... }
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">mul</span>(a: <span style="color:#a6e22e">Self</span>, b: <span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Self</span> { ... }
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">literal_int</span>(x: <span style="color:#66d9ef">i64</span>) -&gt; <span style="color:#a6e22e">Self</span> { ... }
}
</code></pre></div><p>In this post we'll be working with the expression <code>(5 - 3) * (3 + 12)</code>. Here's what that looks like as code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> ExprBoxed::<span style="color:#f92672">*</span>;
<span style="color:#66d9ef">let</span> expr <span style="color:#f92672">=</span> mul(
	sub(literal_int(<span style="color:#ae81ff">5</span>), literal_int(<span style="color:#ae81ff">3</span>)),
	add(literal_int(<span style="color:#ae81ff">3</span>), literal_int(<span style="color:#ae81ff">12</span>)),
);
</code></pre></div><h2 id="expand-and-collapse">Expand and Collapse<a href="#expand-and-collapse" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Previously, we defined two core traits representing the ability to expand a recursive structure out from some seed, and to collapse a recursive structure down into a single value:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#e6db74">/// Support for expanding a data structure from a seed value, one layer at a time
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Expand<span style="color:#f92672">&lt;</span>A, Wrapped<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">expand_layers</span><span style="color:#f92672">&lt;</span>F: Fn(A) -&gt; <span style="color:#a6e22e">Wrapped</span><span style="color:#f92672">&gt;</span>(a: <span style="color:#a6e22e">A</span>, expand_layer: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Self</span>;
}

<span style="color:#e6db74">/// Support for collapsing a data structure into a single value, one layer at a time
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Collapse<span style="color:#f92672">&lt;</span>A, Wrapped<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">collapse_layers</span><span style="color:#f92672">&lt;</span>F: FnMut(Wrapped) -&gt; <span style="color:#a6e22e">A</span><span style="color:#f92672">&gt;</span>(self, collapse_layer: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">A</span>;
}
</code></pre></div><p>We'll be introducing a new recursion backend that implements these traits. This is already implemented in the <code>recursion</code> crate, so this post is concerned mostly with communicating the underlying concepts - not the implementation details.</p>
<h2 id="recursive-data-structure">Recursive Data Structure<a href="#recursive-data-structure" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Instead of using a vector of elements linked by vector indices, we'll construct a vector where linkages are defined only by the <em>relative position</em> of elements. This lets us replace the <code>usize</code> vector indices used in the previous posts with zero-size markers (<code>StackMarker</code>, equivalent to <code>()</code> but given its own name for convenience). This results in an extremely compact representation of recursive structures.</p>
<p>Here's what the data structure looks like. It's provided by the <code>recursion</code> crate, so you won't need to define it yourself.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">StackMarker</span>;

<span style="color:#e6db74">/// Recursive tree made up of layers of some type &#39;Layer&lt;_&gt;&#39;, eg `ExprLayer&lt;_&gt;`
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">RecursiveTree</span><span style="color:#f92672">&lt;</span>Wrapped<span style="color:#f92672">&gt;</span> {
    <span style="color:#e6db74">/// nonempty, in topological-sorted order
</span><span style="color:#e6db74"></span>    elems: Vec<span style="color:#f92672">&lt;</span>Wrapped<span style="color:#f92672">&gt;</span>, <span style="color:#75715e">// Layer&lt;Index&gt; (eg `ExprLayer&lt;()&gt;`)
</span><span style="color:#75715e"></span>}
</code></pre></div><p>Here's a visualization of what this data structure looks like for the expression <code>(5 - 3) * (3 + 12)</code>.</p>

  <img src="/img/rust_schemes/stack_machines_1/simple_expr_structure.png"  alt="simple expr data at rest"  class="center"  style="border-radius: 8px;"  />


<h1 id="expand">Expand<a href="#expand" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Let's see what expanding a boxed expression tree for <code>(5 - 3) * (3 + 12)</code> into a <code>RecursiveTree</code> looks like. We'll look at the implementation soon, but this visualization shows what the computation looks like.</p>

  <img src="/img/rust_schemes/stack_machines_1/simple_expr_expand_only.gif"  alt="execution graph for expansion of a simple expression"  class="center"  style="border-radius: 8px;"  />


<p>You can see the implementation of <code>expand_layers</code> for this structure below, if you're curious, but the important thing is <em>that</em> we have an implementation of <code>Expand</code> provided by the <code>recursion</code> crate, not <em>how</em> its implemented. The whole point of having a crate is not having to examine every implementation detail!</p>
<details>
      <summary>Click to expand code sample</summary>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>A, Underlying, O: <span style="color:#a6e22e">MapLayer</span><span style="color:#f92672">&lt;</span>StackMarker, Unwrapped <span style="color:#f92672">=</span> A, To <span style="color:#f92672">=</span> U<span style="color:#f92672">&gt;&gt;</span> Expand<span style="color:#f92672">&lt;</span>A, O<span style="color:#f92672">&gt;</span>
    <span style="color:#66d9ef">for</span> RecursiveTree<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span>
{
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">expand_layers</span><span style="color:#f92672">&lt;</span>F: Fn(A) -&gt; <span style="color:#a6e22e">O</span><span style="color:#f92672">&gt;</span>(a: <span style="color:#a6e22e">A</span>, generate_layer: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Self</span> {
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> frontier <span style="color:#f92672">=</span> Vec::from([a]);
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> elems <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[];

        <span style="color:#75715e">// expand to build a vec of elems while preserving topo order
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(seed) <span style="color:#f92672">=</span> frontier.pop() {
            <span style="color:#66d9ef">let</span> layer <span style="color:#f92672">=</span> generate_layer(seed);

            <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> topush <span style="color:#f92672">=</span> Vec::new();
            <span style="color:#66d9ef">let</span> layer <span style="color:#f92672">=</span> layer.map_layer(<span style="color:#f92672">|</span>aa<span style="color:#f92672">|</span> {
                topush.push(aa);
                StackMarker
            });
            frontier.extend(topush.into_iter().rev());

            elems.push(layer);
        }

        elems.reverse();

        Self {
            elems,
            _underlying: <span style="color:#a6e22e">std</span>::marker::PhantomData,
        }
    }
}
</code></pre></div></details>
<p>Let's see what expanding a boxed-pointer expression into a <code>RecursiveTree</code> looks like. Since it's already made up of <code>ExprLayer</code> layers, we can just dereference the boxed value using the <code>*</code> operator.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> expr_tree <span style="color:#f92672">=</span> RecursiveTree::expand_layers(expr, <span style="color:#f92672">|</span>ExprBoxed(boxed)<span style="color:#f92672">|</span> <span style="color:#f92672">*</span>boxed)
</code></pre></div><h1 id="collapse">Collapse<a href="#collapse" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Here's what collapsing the <code>RecursiveTree</code> that we just constructed for <code>(5 - 3) * (3 + 12)</code> looks like. As in the last section, this visualization shows what the computation looks like.</p>

  <img src="/img/rust_schemes/stack_machines_1/simple_expr_collapse_only.gif"  alt="execution graph for collapsing of a simple expression"  class="center"  style="border-radius: 8px;"  />


<details>
      <summary>Click to expand code sample</summary>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>A, O, U: <span style="color:#a6e22e">MapLayer</span><span style="color:#f92672">&lt;</span>A, To <span style="color:#f92672">=</span> O, Unwrapped <span style="color:#f92672">=</span> StackMarker<span style="color:#f92672">&gt;&gt;</span> Collapse<span style="color:#f92672">&lt;</span>A, O<span style="color:#f92672">&gt;</span>
    <span style="color:#66d9ef">for</span> RecursiveTree<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span>
{
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">collapse_layers</span><span style="color:#f92672">&lt;</span>F: FnMut(O) -&gt; <span style="color:#a6e22e">A</span><span style="color:#f92672">&gt;</span>(self, <span style="color:#66d9ef">mut</span> collapse_layer: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">A</span> {
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> result_stack <span style="color:#f92672">=</span> Vec::new();

        <span style="color:#66d9ef">for</span> layer <span style="color:#66d9ef">in</span> self.elems.into_iter() {
            <span style="color:#66d9ef">let</span> layer <span style="color:#f92672">=</span> layer.map_layer(<span style="color:#f92672">|</span>_<span style="color:#f92672">|</span> result_stack.pop().unwrap());

            result_stack.push(collapse_layer(layer));
        }

        result_stack.pop().unwrap()
    }
}
</code></pre></div></details>
<p>Here's how we can use this to collapse expressions represented in the <code>RecursiveTree</code> format. Nothing complex, just some simple arithmatic:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> recursive_tree.collapse_layers(<span style="color:#f92672">|</span>expr<span style="color:#f92672">|</span> {
    <span style="color:#66d9ef">use</span> ExprLayer::<span style="color:#f92672">*</span>;
	<span style="color:#66d9ef">match</span> expr {
        Add { a, b } <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">+</span> b,
        Sub { a, b } <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">-</span> b,
        Mul { a, b } <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">*</span> b,
        LiteralInt { literal } <span style="color:#f92672">=&gt;</span> literal,
	}
})
</code></pre></div><h1 id="expand-and-collapse-in-a-single-pass">Expand and Collapse in a Single Pass<a href="#expand-and-collapse-in-a-single-pass" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>As a reminder, the <code>RecursiveTree</code> representing <code>(5 - 3) * (3 + 12)</code> looks like this:</p>

  <img src="/img/rust_schemes/stack_machines_1/simple_expr_structure.png"  alt="simple expr data at rest"  class="center"  style="border-radius: 8px;"  />


<p>Here's a visualization showing what the full evaluation looks like, if we run <code>expand_layers</code> immediately followed by <code>collapse_layers</code>:</p>

  <img src="/img/rust_schemes/stack_machines_1/simple_expr_eval_sorted.gif"  alt="execution graph for expanding and then collapsing a simple expression"  class="center"  style="border-radius: 8px;"  />


<p>But what if could run both operations in a single pass? That would remove the need to hold the full tree in memory. It would also let us avoid introducing a new type of data structure - <code>RecursiveTree</code> - into our projects. It should be possible to evaluate the expression like this, one branch at a time, instead of constructing the full tree:</p>

  <img src="/img/rust_schemes/stack_machines_1/simple_expr_eval.gif"  alt="execution graph for simultaneously expanding and collapsing a simple expression"  class="center"  style="border-radius: 8px;"  />


<p>The function that does this is called <code>expand_and_collapse</code>, and it's provided by the <code>recursion</code> crate. Docs are <a href="https://docs.rs/recursion/0.3.1/recursion/stack_machine/fn.expand_and_collapse.html">here</a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#e6db74">/// For some Layer type, Expandable is Layer&lt;Seed&gt; and Collapsable is Layer&lt;Out&gt;
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">expand_and_collapse</span><span style="color:#f92672">&lt;</span>Seed, Out, Expandable, Collapsable<span style="color:#f92672">&gt;</span>(
    seed: <span style="color:#a6e22e">Seed</span>,
    <span style="color:#66d9ef">mut</span> expand_layer: <span style="color:#a6e22e">impl</span> FnMut(Seed) -&gt; <span style="color:#a6e22e">Expandable</span>,
    <span style="color:#66d9ef">mut</span> collapse_layer: <span style="color:#a6e22e">impl</span> FnMut(Collapsable) -&gt; <span style="color:#a6e22e">Out</span>,
) -&gt; <span style="color:#a6e22e">Out</span>
    Expandable: <span style="color:#a6e22e">MapLayer</span><span style="color:#f92672">&lt;</span>(), Unwrapped <span style="color:#f92672">=</span> Seed<span style="color:#f92672">&gt;</span>,
    <span style="color:#f92672">&lt;</span>Expandable <span style="color:#66d9ef">as</span> MapLayer<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;&gt;</span>::To: <span style="color:#a6e22e">MapLayer</span><span style="color:#f92672">&lt;</span>Out, Unwrapped <span style="color:#f92672">=</span> (), To <span style="color:#f92672">=</span> Collapsable<span style="color:#f92672">&gt;</span>,
</code></pre></div><p>The full implementation is below, if you're curious.</p>
<details>
      <summary>Click to expand code sample</summary>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">expand_and_collapse</span><span style="color:#f92672">&lt;</span>Seed, Out, Expandable, Collapsable<span style="color:#f92672">&gt;</span>(
    seed: <span style="color:#a6e22e">Seed</span>,
    <span style="color:#66d9ef">mut</span> expand_layer: <span style="color:#a6e22e">impl</span> FnMut(Seed) -&gt; <span style="color:#a6e22e">Expandable</span>,
    <span style="color:#66d9ef">mut</span> collapse_layer: <span style="color:#a6e22e">impl</span> FnMut(Collapsable) -&gt; <span style="color:#a6e22e">Out</span>,
) -&gt; <span style="color:#a6e22e">Out</span>
<span style="color:#66d9ef">where</span>
    Expandable: <span style="color:#a6e22e">MapLayer</span><span style="color:#f92672">&lt;</span>(), Unwrapped <span style="color:#f92672">=</span> Seed<span style="color:#f92672">&gt;</span>,
    <span style="color:#f92672">&lt;</span>Expandable <span style="color:#66d9ef">as</span> MapLayer<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;&gt;</span>::To: <span style="color:#a6e22e">MapLayer</span><span style="color:#f92672">&lt;</span>Out, Unwrapped <span style="color:#f92672">=</span> (), To <span style="color:#f92672">=</span> Collapsable<span style="color:#f92672">&gt;</span>,
{
    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">State</span><span style="color:#f92672">&lt;</span>Seed, CollapsableInternal<span style="color:#f92672">&gt;</span> {
        Expand(Seed),
        Collapse(CollapsableInternal),
    }

    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> vals: Vec<span style="color:#f92672">&lt;</span>Out<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[];
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> stack <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[State::Expand(seed)];

    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(item) <span style="color:#f92672">=</span> stack.pop() {
        <span style="color:#66d9ef">match</span> item {
            State::Expand(seed) <span style="color:#f92672">=&gt;</span> {
                <span style="color:#66d9ef">let</span> node <span style="color:#f92672">=</span> expand_layer(seed);
                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> seeds <span style="color:#f92672">=</span> Vec::new();
                <span style="color:#66d9ef">let</span> node <span style="color:#f92672">=</span> node.map_layer(<span style="color:#f92672">|</span>seed<span style="color:#f92672">|</span> {
                    seeds.push(seed)
                });

                stack.push(State::Collapse(node));
                stack.extend(seeds.into_iter().map(State::Expand));
            }
            State::Collapse(node) <span style="color:#f92672">=&gt;</span> {
                <span style="color:#66d9ef">let</span> node <span style="color:#f92672">=</span> node.map_layer(<span style="color:#f92672">|</span>_: ()<span style="color:#f92672">|</span> vals.pop().unwrap());
                vals.push(collapse_layer(node))
            }
        };
    }
    vals.pop().unwrap()
}
</code></pre></div></details>
<p>Here's how we can use this function to evaluate a traditional boxed-pointer recursive expression tree, without constructing an intermediate <code>RecursiveTree</code> - thus saving on both conceptual overhead and memory-usage overhead:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">eval</span>(expr: <span style="color:#a6e22e">ExprBoxed</span>) -&gt; <span style="color:#a6e22e">i63</span> {
    expand_and_collapse(
        expr,                      <span style="color:#75715e">// seed value
</span><span style="color:#75715e"></span>        <span style="color:#f92672">|</span>ExprBoxed(boxed)<span style="color:#f92672">|</span> <span style="color:#f92672">*</span>boxed, <span style="color:#75715e">// expand layer function
</span><span style="color:#75715e"></span>        <span style="color:#f92672">|</span>expr<span style="color:#f92672">|</span> {
            <span style="color:#75715e">// collapse layer function
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">use</span> ExprLayer::<span style="color:#f92672">*</span>;
            <span style="color:#66d9ef">match</span> expr {
                Add { a, b } <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">+</span> b,
                Sub { a, b } <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">-</span> b,
                Mul { a, b } <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">*</span> b,
                LiteralInt { literal } <span style="color:#f92672">=&gt;</span> literal,
            }
        },
    )
}
</code></pre></div><p>This is <em>fully generic</em>, and can be used with any recursive structure, not just the simple expression language used in this post. In the next post, I'll show how to use <code>expand_and_collapse</code> to build an expression language for matching filesystem entities, with features like short-circuiting to minimize syscalls, arena allocation (as a flex), and, of course, many more execution graphs.</p>
<h1 id="computer-science-implications">Computer Science Implications<a href="#computer-science-implications" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>If you have a background in data structures and algorithms, and if you looked closely at the implementation details of the above functions, you might recognize them as implementing stack machines.</p>
<p>If you're familiar with Haskell and Recursion schemes, you might recognize <code>expand_and_collapse</code> as a hylomorphism. If you don't know what the hell a hylomorphism is and are interested in learning, there's an <a href="https://blog.sumtypeofway.com/posts/recursion-schemes-part-5.html">excellent blog post here</a> that goes into some detail on the concept.</p>
<p>There does appear to be a fundamental correspondence between stack machines and hylomorphisms. This is interesting, because these ideas arise in different corners of the computer science universe. That said, this isn't <em>that</em> surprising, as both are descriptions of the same thing: recursion.</p>
<h1 id="thank-you">Thank you<a href="#thank-you" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Thank you to <a href="https://twitter.com/munin">Fiona</a>, <a href="https://twitter.com/sunshowers6">Rain</a>, <a href="https://twitter.com/mycoliza">Eliza</a>, among others, for reviewing drafts of this post.</p>
      </div></div>

  
  
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        
        <span class="button next">
            <a href="https://recursion.wtf/posts/rust_schemes_2/">
                <span class="button__text">Fully generic recursion in Rust</span>
                <span class="button__icon">→</span>
            </a>
        </span>
        
    </div>
</div>

  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2022 Powered by <a href="http://gohugo.io">Hugo</a></span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="https://recursion.wtf/assets/main.js"></script>
<script src="https://recursion.wtf/assets/prism.js"></script>







  
</div>

</body>
</html>
